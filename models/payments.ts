//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming



export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class BooleanApiResult implements IBooleanApiResult {
    errors?: ApiError[] | undefined;
    results?: boolean[] | undefined;
    result?: boolean;

    constructor(data?: IBooleanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): BooleanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["result"] = this.result;
        return data;
    }
}

export interface IBooleanApiResult {
    errors?: ApiError[] | undefined;
    results?: boolean[] | undefined;
    result?: boolean;
}

export class ObjectApiResult implements IObjectApiResult {
    errors?: ApiError[] | undefined;
    results?: any[] | undefined;
    result?: any | undefined;

    constructor(data?: IObjectApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ObjectApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["result"] = this.result;
        return data;
    }
}

export interface IObjectApiResult {
    errors?: ApiError[] | undefined;
    results?: any[] | undefined;
    result?: any | undefined;
}

/** API request model to capture already authorized transaction. */
export class TransactionCaptureRequest implements ITransactionCaptureRequest {
    /** User's global identifier in system. */
    externalUserId?: string | undefined;
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    /** Transaction identifier (DB id at this time). */
    transactionId?: number;

    constructor(data?: ITransactionCaptureRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.externalUserId = _data["externalUserId"];
            this.sessionId = _data["sessionId"];
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): TransactionCaptureRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCaptureRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalUserId"] = this.externalUserId;
        data["sessionId"] = this.sessionId;
        data["transactionId"] = this.transactionId;
        return data;
    }
}

/** API request model to capture already authorized transaction. */
export interface ITransactionCaptureRequest {
    /** User's global identifier in system. */
    externalUserId?: string | undefined;
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    /** Transaction identifier (DB id at this time). */
    transactionId?: number;
}

/** API request model to create payment transaction. */
export class TransactionCreateRequest implements ITransactionCreateRequest {
    /** User's global identifier in system. */
    externalUserId?: string | undefined;
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    /** Associated order id. */
    orderId?: number;
    paymentInfo?: PaymentInfo;

    constructor(data?: ITransactionCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.externalUserId = _data["externalUserId"];
            this.sessionId = _data["sessionId"];
            this.orderId = _data["orderId"];
            this.paymentInfo = _data["paymentInfo"] ? PaymentInfo.fromJS(_data["paymentInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransactionCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalUserId"] = this.externalUserId;
        data["sessionId"] = this.sessionId;
        data["orderId"] = this.orderId;
        data["paymentInfo"] = this.paymentInfo ? this.paymentInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** API request model to create payment transaction. */
export interface ITransactionCreateRequest {
    /** User's global identifier in system. */
    externalUserId?: string | undefined;
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    /** Associated order id. */
    orderId?: number;
    paymentInfo?: PaymentInfo;
}

/** Chassis Auth version API request model to Create or Update vault payment method. */
export class VaultPaymentCreateUpdateRequestAuth implements IVaultPaymentCreateUpdateRequestAuth {
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    savePaymentMethodInfo?: SavePaymentMethodInfo;

    constructor(data?: IVaultPaymentCreateUpdateRequestAuth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.savePaymentMethodInfo = _data["savePaymentMethodInfo"] ? SavePaymentMethodInfo.fromJS(_data["savePaymentMethodInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): VaultPaymentCreateUpdateRequestAuth {
        data = typeof data === 'object' ? data : {};
        let result = new VaultPaymentCreateUpdateRequestAuth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["savePaymentMethodInfo"] = this.savePaymentMethodInfo ? this.savePaymentMethodInfo.toJSON() : <any>undefined;
        return data;
    }
}

/** Chassis Auth version API request model to Create or Update vault payment method. */
export interface IVaultPaymentCreateUpdateRequestAuth {
    /** "TCG_VisitorKey" cookie value from Dominaria. 
User's current session ID, used to tie a user's action before and after log in or account creation for fraud prevention purposes. */
    sessionId?: string | undefined;
    savePaymentMethodInfo?: SavePaymentMethodInfo;
}

export class CreateRefundRequest implements ICreateRefundRequest {
    transactionId?: string | undefined;
    amount?: number | undefined;

    constructor(data?: ICreateRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionId = _data["transactionId"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): CreateRefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionId"] = this.transactionId;
        data["amount"] = this.amount;
        return data;
    }
}

export interface ICreateRefundRequest {
    transactionId?: string | undefined;
    amount?: number | undefined;
}

export class CreateSubscriptionRequest implements ICreateSubscriptionRequest {
    paymentMethodToken?: string | undefined;
    planId?: string | undefined;
    firstBillingDate?: Date | undefined;
    price?: number | undefined;

    constructor(data?: ICreateSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodToken = _data["paymentMethodToken"];
            this.planId = _data["planId"];
            this.firstBillingDate = _data["firstBillingDate"] ? new Date(_data["firstBillingDate"].toString()) : <any>undefined;
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): CreateSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodToken"] = this.paymentMethodToken;
        data["planId"] = this.planId;
        data["firstBillingDate"] = this.firstBillingDate ? this.firstBillingDate.toISOString() : <any>undefined;
        data["price"] = this.price;
        return data;
    }
}

export interface ICreateSubscriptionRequest {
    paymentMethodToken?: string | undefined;
    planId?: string | undefined;
    firstBillingDate?: Date | undefined;
    price?: number | undefined;
}

/** Generic address model. */
export class Address implements IAddress {
    /** Gets or sets the First Name associated with this address. */
    firstName?: string | undefined;
    /** Gets or sets the Last Name associated with this address. */
    lastName?: string | undefined;
    /** Gets or sets line 1 of the street address. */
    addressLine1?: string | undefined;
    /** Gets or sets line 2 of the street address. */
    addressLine2?: string | undefined;
    /** Gets or sets the city for this address. */
    city?: string | undefined;
    /** Gets or sets the state/province/region for this address. */
    stateProvinceRegion?: string | undefined;
    /** Gets or sets the zip/postal code for this address. */
    zipCode?: string | undefined;
    /** Gets or sets the country for this address. */
    countryCode?: string | undefined;
    /** Gets or sets the phone number for this address. */
    phone?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.stateProvinceRegion = _data["stateProvinceRegion"];
            this.zipCode = _data["zipCode"];
            this.countryCode = _data["countryCode"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["stateProvinceRegion"] = this.stateProvinceRegion;
        data["zipCode"] = this.zipCode;
        data["countryCode"] = this.countryCode;
        data["phone"] = this.phone;
        return data;
    }
}

/** Generic address model. */
export interface IAddress {
    /** Gets or sets the First Name associated with this address. */
    firstName?: string | undefined;
    /** Gets or sets the Last Name associated with this address. */
    lastName?: string | undefined;
    /** Gets or sets line 1 of the street address. */
    addressLine1?: string | undefined;
    /** Gets or sets line 2 of the street address. */
    addressLine2?: string | undefined;
    /** Gets or sets the city for this address. */
    city?: string | undefined;
    /** Gets or sets the state/province/region for this address. */
    stateProvinceRegion?: string | undefined;
    /** Gets or sets the zip/postal code for this address. */
    zipCode?: string | undefined;
    /** Gets or sets the country for this address. */
    countryCode?: string | undefined;
    /** Gets or sets the phone number for this address. */
    phone?: string | undefined;
}

/** ApplePay account details response from provider. */
export class ApplePayDetails implements IApplePayDetails {
    token?: string | undefined;
    cardHolderName?: string | undefined;
    bin?: string | undefined;
    lastFour?: string | undefined;
    expirationMonth?: string | undefined;
    expirationYear?: string | undefined;

    constructor(data?: IApplePayDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.cardHolderName = _data["cardHolderName"];
            this.bin = _data["bin"];
            this.lastFour = _data["lastFour"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
        }
    }

    static fromJS(data: any): ApplePayDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ApplePayDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["cardHolderName"] = this.cardHolderName;
        data["bin"] = this.bin;
        data["lastFour"] = this.lastFour;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        return data;
    }
}

/** ApplePay account details response from provider. */
export interface IApplePayDetails {
    token?: string | undefined;
    cardHolderName?: string | undefined;
    bin?: string | undefined;
    lastFour?: string | undefined;
    expirationMonth?: string | undefined;
    expirationYear?: string | undefined;
}

/** Credit card info response from provider. */
export class CreditCardDetails implements ICreditCardDetails {
    /** The type of card. */
    cardType?: string | undefined;
    /** Name on card */
    cardHolderName?: string | undefined;
    /** The first 6 digits of the credit card, known as the bank identification number. (For Sift) */
    bin?: string | undefined;
    /** Last 4 digits. */
    lastFour?: string | undefined;
    /** Exp month on the card. */
    expirationMonth?: string | undefined;
    /** Exp year on the card. */
    expirationYear?: string | undefined;
    /** Gets or sets a value indicating whether the credit card is expired. */
    isExpired?: boolean;
    billingAddress?: Address;

    constructor(data?: ICreditCardDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cardType = _data["cardType"];
            this.cardHolderName = _data["cardHolderName"];
            this.bin = _data["bin"];
            this.lastFour = _data["lastFour"];
            this.expirationMonth = _data["expirationMonth"];
            this.expirationYear = _data["expirationYear"];
            this.isExpired = _data["isExpired"];
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreditCardDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreditCardDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cardType"] = this.cardType;
        data["cardHolderName"] = this.cardHolderName;
        data["bin"] = this.bin;
        data["lastFour"] = this.lastFour;
        data["expirationMonth"] = this.expirationMonth;
        data["expirationYear"] = this.expirationYear;
        data["isExpired"] = this.isExpired;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        return data;
    }
}

/** Credit card info response from provider. */
export interface ICreditCardDetails {
    /** The type of card. */
    cardType?: string | undefined;
    /** Name on card */
    cardHolderName?: string | undefined;
    /** The first 6 digits of the credit card, known as the bank identification number. (For Sift) */
    bin?: string | undefined;
    /** Last 4 digits. */
    lastFour?: string | undefined;
    /** Exp month on the card. */
    expirationMonth?: string | undefined;
    /** Exp year on the card. */
    expirationYear?: string | undefined;
    /** Gets or sets a value indicating whether the credit card is expired. */
    isExpired?: boolean;
    billingAddress?: Address;
}

/** Payment info input model. */
export class PaymentInfo implements IPaymentInfo {
    paymentType?: PaymentType;
    /** Transaction amount to charge. */
    amount?: number;
    /** One time use token/nonce or Vault token for saved payments. Depends on PaymentType. */
    paymentToken?: string | undefined;
    /** Client side device data that is autumatically collected and useful for some situations. */
    deviceData?: string | undefined;
    /** True if it's "PayLater" or user is in "Kount Fraud Review Bypass" group */
    skipAdvancedFraudCheck?: boolean;
    /** Store in vault on success or not. */
    saveToVault?: boolean;
    /** Whether or not to apply "Store Credit.
TODO: will be addressed in other ticket. */
    useStoreCredit?: boolean;
    paypalInputInfo?: PaypalInputInfo;
    shippingAddress?: Address;
    billingAddress?: Address;

    constructor(data?: IPaymentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentType = _data["paymentType"];
            this.amount = _data["amount"];
            this.paymentToken = _data["paymentToken"];
            this.deviceData = _data["deviceData"];
            this.skipAdvancedFraudCheck = _data["skipAdvancedFraudCheck"];
            this.saveToVault = _data["saveToVault"];
            this.useStoreCredit = _data["useStoreCredit"];
            this.paypalInputInfo = _data["paypalInputInfo"] ? PaypalInputInfo.fromJS(_data["paypalInputInfo"]) : <any>undefined;
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentType"] = this.paymentType;
        data["amount"] = this.amount;
        data["paymentToken"] = this.paymentToken;
        data["deviceData"] = this.deviceData;
        data["skipAdvancedFraudCheck"] = this.skipAdvancedFraudCheck;
        data["saveToVault"] = this.saveToVault;
        data["useStoreCredit"] = this.useStoreCredit;
        data["paypalInputInfo"] = this.paypalInputInfo ? this.paypalInputInfo.toJSON() : <any>undefined;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        return data;
    }
}

/** Payment info input model. */
export interface IPaymentInfo {
    paymentType?: PaymentType;
    /** Transaction amount to charge. */
    amount?: number;
    /** One time use token/nonce or Vault token for saved payments. Depends on PaymentType. */
    paymentToken?: string | undefined;
    /** Client side device data that is autumatically collected and useful for some situations. */
    deviceData?: string | undefined;
    /** True if it's "PayLater" or user is in "Kount Fraud Review Bypass" group */
    skipAdvancedFraudCheck?: boolean;
    /** Store in vault on success or not. */
    saveToVault?: boolean;
    /** Whether or not to apply "Store Credit.
TODO: will be addressed in other ticket. */
    useStoreCredit?: boolean;
    paypalInputInfo?: PaypalInputInfo;
    shippingAddress?: Address;
    billingAddress?: Address;
}

export class PaymentMethod implements IPaymentMethod {
    token?: string | undefined;
    isDefault?: boolean;
    hasActiveSubscription?: boolean;
    lastUsedDate?: Date | undefined;
    updatedAt?: Date | undefined;
    creditCard?: CreditCardDetails;
    payPalAccount?: PaypalDetails;

    constructor(data?: IPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.isDefault = _data["isDefault"];
            this.hasActiveSubscription = _data["hasActiveSubscription"];
            this.lastUsedDate = _data["lastUsedDate"] ? new Date(_data["lastUsedDate"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.creditCard = _data["creditCard"] ? CreditCardDetails.fromJS(_data["creditCard"]) : <any>undefined;
            this.payPalAccount = _data["payPalAccount"] ? PaypalDetails.fromJS(_data["payPalAccount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["isDefault"] = this.isDefault;
        data["hasActiveSubscription"] = this.hasActiveSubscription;
        data["lastUsedDate"] = this.lastUsedDate ? this.lastUsedDate.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["creditCard"] = this.creditCard ? this.creditCard.toJSON() : <any>undefined;
        data["payPalAccount"] = this.payPalAccount ? this.payPalAccount.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentMethod {
    token?: string | undefined;
    isDefault?: boolean;
    hasActiveSubscription?: boolean;
    lastUsedDate?: Date | undefined;
    updatedAt?: Date | undefined;
    creditCard?: CreditCardDetails;
    payPalAccount?: PaypalDetails;
}

export class PaymentMethodApiResult implements IPaymentMethodApiResult {
    errors?: ApiError[] | undefined;
    results?: PaymentMethod[] | undefined;
    result?: PaymentMethod;

    constructor(data?: IPaymentMethodApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentMethod.fromJS(item));
            }
            this.result = _data["result"] ? PaymentMethod.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentMethodApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentMethodApiResult {
    errors?: ApiError[] | undefined;
    results?: PaymentMethod[] | undefined;
    result?: PaymentMethod;
}

export class PaymentProcessorResponse implements IPaymentProcessorResponse {
    wasSuccessful?: boolean;
    creditCardDetails?: CreditCardDetails;
    paypalDetails?: PaypalDetails;
    applePayDetails?: ApplePayDetails;
    vaultPaymentMethod?: VaultPaymentMethod;
    transactionId?: number;

    constructor(data?: IPaymentProcessorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wasSuccessful = _data["wasSuccessful"];
            this.creditCardDetails = _data["creditCardDetails"] ? CreditCardDetails.fromJS(_data["creditCardDetails"]) : <any>undefined;
            this.paypalDetails = _data["paypalDetails"] ? PaypalDetails.fromJS(_data["paypalDetails"]) : <any>undefined;
            this.applePayDetails = _data["applePayDetails"] ? ApplePayDetails.fromJS(_data["applePayDetails"]) : <any>undefined;
            this.vaultPaymentMethod = _data["vaultPaymentMethod"] ? VaultPaymentMethod.fromJS(_data["vaultPaymentMethod"]) : <any>undefined;
            this.transactionId = _data["transactionId"];
        }
    }

    static fromJS(data: any): PaymentProcessorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProcessorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wasSuccessful"] = this.wasSuccessful;
        data["creditCardDetails"] = this.creditCardDetails ? this.creditCardDetails.toJSON() : <any>undefined;
        data["paypalDetails"] = this.paypalDetails ? this.paypalDetails.toJSON() : <any>undefined;
        data["applePayDetails"] = this.applePayDetails ? this.applePayDetails.toJSON() : <any>undefined;
        data["vaultPaymentMethod"] = this.vaultPaymentMethod ? this.vaultPaymentMethod.toJSON() : <any>undefined;
        data["transactionId"] = this.transactionId;
        return data;
    }
}

export interface IPaymentProcessorResponse {
    wasSuccessful?: boolean;
    creditCardDetails?: CreditCardDetails;
    paypalDetails?: PaypalDetails;
    applePayDetails?: ApplePayDetails;
    vaultPaymentMethod?: VaultPaymentMethod;
    transactionId?: number;
}

export class PaymentProcessorResponseApiResult implements IPaymentProcessorResponseApiResult {
    errors?: ApiError[] | undefined;
    results?: PaymentProcessorResponse[] | undefined;
    result?: PaymentProcessorResponse;

    constructor(data?: IPaymentProcessorResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentProcessorResponse.fromJS(item));
            }
            this.result = _data["result"] ? PaymentProcessorResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PaymentProcessorResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentProcessorResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymentProcessorResponseApiResult {
    errors?: ApiError[] | undefined;
    results?: PaymentProcessorResponse[] | undefined;
    result?: PaymentProcessorResponse;
}

/** Payment types (commented types are from Dominaria that are not used here at this time). */
export enum PaymentType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

/** Paypal account info response from provider. */
export class PaypalDetails implements IPaypalDetails {
    payerId?: string | undefined;
    payerEmail?: string | undefined;
    payerStatus?: string | undefined;
    protectionEligibility?: string | undefined;

    constructor(data?: IPaypalDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payerId = _data["payerId"];
            this.payerEmail = _data["payerEmail"];
            this.payerStatus = _data["payerStatus"];
            this.protectionEligibility = _data["protectionEligibility"];
        }
    }

    static fromJS(data: any): PaypalDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PaypalDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payerId"] = this.payerId;
        data["payerEmail"] = this.payerEmail;
        data["payerStatus"] = this.payerStatus;
        data["protectionEligibility"] = this.protectionEligibility;
        return data;
    }
}

/** Paypal account info response from provider. */
export interface IPaypalDetails {
    payerId?: string | undefined;
    payerEmail?: string | undefined;
    payerStatus?: string | undefined;
    protectionEligibility?: string | undefined;
}

/** Paypal payment input data model (for backward compatibility). */
export class PaypalInputInfo implements IPaypalInputInfo {
    /** orderId - paypal popup website token */
    expressToken?: string | undefined;
    countryCode?: string | undefined;

    constructor(data?: IPaypalInputInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expressToken = _data["expressToken"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): PaypalInputInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PaypalInputInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expressToken"] = this.expressToken;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

/** Paypal payment input data model (for backward compatibility). */
export interface IPaypalInputInfo {
    /** orderId - paypal popup website token */
    expressToken?: string | undefined;
    countryCode?: string | undefined;
}

/** Save payment method info input model. */
export class SavePaymentMethodInfo implements ISavePaymentMethodInfo {
    /** One time use nonce. Tokenized fields (or Paypal account) by front-end SDK. */
    paymentMethodNonce?: string | undefined;
    paymentType?: PaymentType;
    /** Gets or sets a value indicating whether the payment method is the default for a Customer. */
    isDefault?: boolean;
    /** Client side device data that is autumatically collected and useful for Premium Fraud Management Tools. */
    deviceData?: string | undefined;
    billingAddress?: Address;
    /** Vault payment token, used for identifying payment method during update operation. */
    token?: string | undefined;

    constructor(data?: ISavePaymentMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodNonce = _data["paymentMethodNonce"];
            this.paymentType = _data["paymentType"];
            this.isDefault = _data["isDefault"];
            this.deviceData = _data["deviceData"];
            this.billingAddress = _data["billingAddress"] ? Address.fromJS(_data["billingAddress"]) : <any>undefined;
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): SavePaymentMethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SavePaymentMethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodNonce"] = this.paymentMethodNonce;
        data["paymentType"] = this.paymentType;
        data["isDefault"] = this.isDefault;
        data["deviceData"] = this.deviceData;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["token"] = this.token;
        return data;
    }
}

/** Save payment method info input model. */
export interface ISavePaymentMethodInfo {
    /** One time use nonce. Tokenized fields (or Paypal account) by front-end SDK. */
    paymentMethodNonce?: string | undefined;
    paymentType?: PaymentType;
    /** Gets or sets a value indicating whether the payment method is the default for a Customer. */
    isDefault?: boolean;
    /** Client side device data that is autumatically collected and useful for Premium Fraud Management Tools. */
    deviceData?: string | undefined;
    billingAddress?: Address;
    /** Vault payment token, used for identifying payment method during update operation. */
    token?: string | undefined;
}

/** Model for saved payment method. */
export class VaultPaymentMethod implements IVaultPaymentMethod {
    /** Customer Id. */
    userId?: string | undefined;
    /** Vault payment token. */
    token?: string | undefined;
    /** Gets or sets a value indicating whether the payment method is the default for a Customer. (From Braintree) */
    isDefault?: boolean;
    /** Gets or sets the date and time when the payment method was last used. */
    lastUsedDate?: Date | undefined;

    constructor(data?: IVaultPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.isDefault = _data["isDefault"];
            this.lastUsedDate = _data["lastUsedDate"] ? new Date(_data["lastUsedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): VaultPaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new VaultPaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["isDefault"] = this.isDefault;
        data["lastUsedDate"] = this.lastUsedDate ? this.lastUsedDate.toISOString() : <any>undefined;
        return data;
    }
}

/** Model for saved payment method. */
export interface IVaultPaymentMethod {
    /** Customer Id. */
    userId?: string | undefined;
    /** Vault payment token. */
    token?: string | undefined;
    /** Gets or sets a value indicating whether the payment method is the default for a Customer. (From Braintree) */
    isDefault?: boolean;
    /** Gets or sets the date and time when the payment method was last used. */
    lastUsedDate?: Date | undefined;
}

export class PaymentMethod2 implements IPaymentMethod2 {
    token?: string | undefined;
    paymentType?: string | undefined;
    isDefault?: boolean;

    constructor(data?: IPaymentMethod2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.paymentType = _data["paymentType"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): PaymentMethod2 {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethod2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["paymentType"] = this.paymentType;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IPaymentMethod2 {
    token?: string | undefined;
    paymentType?: string | undefined;
    isDefault?: boolean;
}

export class Subscription implements ISubscription {
    subscriptionId?: string | undefined;
    paymentMethodToken?: string | undefined;
    planId?: string | undefined;
    price?: number | undefined;
    description?: string | undefined;
    balance?: number | undefined;
    currentBillingCycle?: number | undefined;
    firstBillingDate?: Date | undefined;
    nextBillingDate?: Date | undefined;
    daysPastDue?: number | undefined;
    status?: string | undefined;
    readonly transactions?: Transaction[] | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.paymentMethodToken = _data["paymentMethodToken"];
            this.planId = _data["planId"];
            this.price = _data["price"];
            this.description = _data["description"];
            this.balance = _data["balance"];
            this.currentBillingCycle = _data["currentBillingCycle"];
            this.firstBillingDate = _data["firstBillingDate"] ? new Date(_data["firstBillingDate"].toString()) : <any>undefined;
            this.nextBillingDate = _data["nextBillingDate"] ? new Date(_data["nextBillingDate"].toString()) : <any>undefined;
            this.daysPastDue = _data["daysPastDue"];
            this.status = _data["status"];
            if (Array.isArray(_data["transactions"])) {
                (<any>this).transactions = [] as any;
                for (let item of _data["transactions"])
                    (<any>this).transactions!.push(Transaction.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["paymentMethodToken"] = this.paymentMethodToken;
        data["planId"] = this.planId;
        data["price"] = this.price;
        data["description"] = this.description;
        data["balance"] = this.balance;
        data["currentBillingCycle"] = this.currentBillingCycle;
        data["firstBillingDate"] = this.firstBillingDate ? this.firstBillingDate.toISOString() : <any>undefined;
        data["nextBillingDate"] = this.nextBillingDate ? this.nextBillingDate.toISOString() : <any>undefined;
        data["daysPastDue"] = this.daysPastDue;
        data["status"] = this.status;
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISubscription {
    subscriptionId?: string | undefined;
    paymentMethodToken?: string | undefined;
    planId?: string | undefined;
    price?: number | undefined;
    description?: string | undefined;
    balance?: number | undefined;
    currentBillingCycle?: number | undefined;
    firstBillingDate?: Date | undefined;
    nextBillingDate?: Date | undefined;
    daysPastDue?: number | undefined;
    status?: string | undefined;
    transactions?: Transaction[] | undefined;
}

export class SubscriptionApiResult implements ISubscriptionApiResult {
    errors?: ApiError[] | undefined;
    results?: Subscription[] | undefined;
    result?: Subscription;

    constructor(data?: ISubscriptionApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Subscription.fromJS(item));
            }
            this.result = _data["result"] ? Subscription.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISubscriptionApiResult {
    errors?: ApiError[] | undefined;
    results?: Subscription[] | undefined;
    result?: Subscription;
}

export class SubscriptionDetails implements ISubscriptionDetails {
    billingPeriodStartDate?: Date | undefined;
    billingPeriodEndDate?: Date | undefined;

    constructor(data?: ISubscriptionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.billingPeriodStartDate = _data["billingPeriodStartDate"] ? new Date(_data["billingPeriodStartDate"].toString()) : <any>undefined;
            this.billingPeriodEndDate = _data["billingPeriodEndDate"] ? new Date(_data["billingPeriodEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubscriptionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingPeriodStartDate"] = this.billingPeriodStartDate ? this.billingPeriodStartDate.toISOString() : <any>undefined;
        data["billingPeriodEndDate"] = this.billingPeriodEndDate ? this.billingPeriodEndDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ISubscriptionDetails {
    billingPeriodStartDate?: Date | undefined;
    billingPeriodEndDate?: Date | undefined;
}

export class Transaction implements ITransaction {
    amount?: number | undefined;
    createdAt?: Date | undefined;
    status?: string | undefined;
    processorResponseCode?: string | undefined;
    processorResponseText?: string | undefined;
    avsPostalCodeResponseCode?: string | undefined;
    avsStreetAddressResponseCode?: string | undefined;
    cvvResponseCode?: string | undefined;
    readonly refundTransactionIds?: string[] | undefined;
    paymentMethod?: any | undefined;
    id?: string | undefined;
    refundedTransactionId?: string | undefined;
    subscriptionDetails?: SubscriptionDetails;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.processorResponseCode = _data["processorResponseCode"];
            this.processorResponseText = _data["processorResponseText"];
            this.avsPostalCodeResponseCode = _data["avsPostalCodeResponseCode"];
            this.avsStreetAddressResponseCode = _data["avsStreetAddressResponseCode"];
            this.cvvResponseCode = _data["cvvResponseCode"];
            if (Array.isArray(_data["refundTransactionIds"])) {
                (<any>this).refundTransactionIds = [] as any;
                for (let item of _data["refundTransactionIds"])
                    (<any>this).refundTransactionIds!.push(item);
            }
            this.paymentMethod = _data["paymentMethod"];
            this.id = _data["id"];
            this.refundedTransactionId = _data["refundedTransactionId"];
            this.subscriptionDetails = _data["subscriptionDetails"] ? SubscriptionDetails.fromJS(_data["subscriptionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["processorResponseCode"] = this.processorResponseCode;
        data["processorResponseText"] = this.processorResponseText;
        data["avsPostalCodeResponseCode"] = this.avsPostalCodeResponseCode;
        data["avsStreetAddressResponseCode"] = this.avsStreetAddressResponseCode;
        data["cvvResponseCode"] = this.cvvResponseCode;
        if (Array.isArray(this.refundTransactionIds)) {
            data["refundTransactionIds"] = [];
            for (let item of this.refundTransactionIds)
                data["refundTransactionIds"].push(item);
        }
        data["paymentMethod"] = this.paymentMethod;
        data["id"] = this.id;
        data["refundedTransactionId"] = this.refundedTransactionId;
        data["subscriptionDetails"] = this.subscriptionDetails ? this.subscriptionDetails.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransaction {
    amount?: number | undefined;
    createdAt?: Date | undefined;
    status?: string | undefined;
    processorResponseCode?: string | undefined;
    processorResponseText?: string | undefined;
    avsPostalCodeResponseCode?: string | undefined;
    avsStreetAddressResponseCode?: string | undefined;
    cvvResponseCode?: string | undefined;
    refundTransactionIds?: string[] | undefined;
    paymentMethod?: any | undefined;
    id?: string | undefined;
    refundedTransactionId?: string | undefined;
    subscriptionDetails?: SubscriptionDetails;
}

export class UpdateSubscriptionRequest implements IUpdateSubscriptionRequest {
    paymentMethodToken?: string | undefined;
    price?: number | undefined;

    constructor(data?: IUpdateSubscriptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethodToken = _data["paymentMethodToken"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): UpdateSubscriptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubscriptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethodToken"] = this.paymentMethodToken;
        data["price"] = this.price;
        return data;
    }
}

export interface IUpdateSubscriptionRequest {
    paymentMethodToken?: string | undefined;
    price?: number | undefined;
}

export class User implements IUser {
    userId?: number;
    readonly subscriptions?: Subscription[] | undefined;
    readonly paymentMethods?: PaymentMethod2[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            if (Array.isArray(_data["subscriptions"])) {
                (<any>this).subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    (<any>this).subscriptions!.push(Subscription.fromJS(item));
            }
            if (Array.isArray(_data["paymentMethods"])) {
                (<any>this).paymentMethods = [] as any;
                for (let item of _data["paymentMethods"])
                    (<any>this).paymentMethods!.push(PaymentMethod2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        if (Array.isArray(this.paymentMethods)) {
            data["paymentMethods"] = [];
            for (let item of this.paymentMethods)
                data["paymentMethods"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    userId?: number;
    subscriptions?: Subscription[] | undefined;
    paymentMethods?: PaymentMethod2[] | undefined;
}

export class UserApiResult implements IUserApiResult {
    errors?: ApiError[] | undefined;
    results?: User[] | undefined;
    result?: User;

    constructor(data?: IUserApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(User.fromJS(item));
            }
            this.result = _data["result"] ? User.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserApiResult {
    errors?: ApiError[] | undefined;
    results?: User[] | undefined;
    result?: User;
}

export class ApiError implements IApiError {
    code?: string | undefined;
    message?: string | undefined;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface IApiError {
    code?: string | undefined;
    message?: string | undefined;
}


