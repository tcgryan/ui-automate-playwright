//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface ICartClient {
    /**
     * Creates a new cart for a user who is not logged in.
     * @param sellerKey (optional) Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
    marketplace cart omits this value.  In-context carts for a specific seller's Pro site
    have that seller's key provided.
     * @return Cart key of the created cart
     */
    createAnonymousCart(sellerKey: string | undefined): Promise<CreatedCartKeyApiResult>;
    /**
     * Creates a new cart belonging to the specified user.
     * @param body (optional) Request containing create parameters
     * @return Cart key of the created cart
     */
    createUserCart(body: CreateCartRequest | undefined): Promise<CreatedCartKeyApiResult>;
    /**
     * Creates a new cart belonging to the specified user.
     * @param body (optional) Request containing create parameters
     * @return Cart key of the created cart
     */
    createCartOptimizerCart(body: CreateCartOptimizerCartRequest | undefined): Promise<CreatedCartKeyApiResult>;
    /**
     * Clears the cart and deletes the cookie associated to it.
     * @param cartKey The key of the cart to clear.
     * @param orderId The order id
     * @return The key of the cart to clear.
     */
    clearCart(cartKey: string, orderId: number): Promise<void>;
    /**
     * Adds a new item to a cart, or increases an existing cart item's requested quantity.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the item to add to the cart.
     * @return CartApi.Models.CartItems.AddItemResponse containing information about the result of the operation.
     */
    addItem(cartKey: string, body: AddItemRequest | undefined): Promise<AddItemResponseApiResult>;
    /**
     * Delete a single item from a cart.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param cartItemId The id of the cart item to delete.
     * @return Success.
     */
    deleteItem(cartKey: string, cartItemId: number): Promise<void>;
    /**
     * Update the quantity for a single item from a cart.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param cartItemId The id of the cart item to update.
     * @param body (optional) The new amount to set the requested quantity to.
     * @return Success.
     */
    updateItem(cartKey: string, cartItemId: number, body: UpdateItemRequest | undefined): Promise<UpdateItemResponseApiResult>;
    /**
     * Gets a list of all the items in the cart associated with the given cart key.
     * @param cartKey The dbo.Cart.CartKey of the cart related to the list of cart items being requested.
     * @return A list of all the items in the cart associated with the given cart key.
     */
    getAllItems(cartKey: string): Promise<CartItemResponseListApiResult>;
    /**
     * Adds items to a cart in bulk.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the items to add to the cart.
     * @return CartApi.Models.CartItems.BulkAddItemsResponse containing information about the result of the operation.
     */
    bulkAddItems(cartKey: string, body: BulkAddItemsRequest | undefined): Promise<BulkAddItemsResponseApiResult>;
    /**
     * Delete items from the cart in bulk.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param body (optional) The list of items to delete from the cart.
     * @return Success.
     */
    bulkDeleteItems(cartKey: string, body: BulkDeleteItemsRequest | undefined): Promise<void>;
    /**
     * Delete all items from a cart (clear the cart).
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @return Success.
     */
    deleteAllItems(cartKey: string): Promise<void>;
    /**
     * Updates items in a cart in bulk.
     * @param cartKey The cart key associated with the Cart to modify.
     * @param body (optional) Contains information about the items to modify in the cart.
     * @return CartApi.Models.CartItems.BulkUpdateItemsResponse containing information about the result of the operation.
     */
    bulkUpdateItems(cartKey: string, body: BulkUpdateItemsRequest | undefined): Promise<BulkUpdateItemsResponseApiResult>;
    /**
     * Adds items to Save for Later while removing them from a cart
     * @param body (optional) A request object describing the cart items to move and to where
     * @return Success
     */
    moveToSaveForLater(body: MoveToSaveForLaterRequest | undefined): Promise<MoveToSaveForLaterResultApiResult>;
    /**
     * Adds a listo to a cart
     * @param cartKey Key of the cart to modify
     * @param body (optional) Contains information about the listo to add to the cart
     * @return Results of adding the listo
     */
    addListo(cartKey: string, body: AddListoRequest | undefined): Promise<AddListoResultApiResult>;
    /**
     * Remove cart shipping address (typically used for a guest user).
     * @param cartKey Cart key of cart the shipping address is being removed from.
     * @return Cart shipping address successfully removed.
     */
    removeShippingAddress(cartKey: string): Promise<ApiResult>;
    /**
     * Gets the Cart's selected shipping options.
     * @param cartKey The key associated with the cart.
     * @return Success
     */
    getSelectedShippingOptions(cartKey: string): Promise<SavedVendorShippingOption[]>;
    /**
     * Update cart package shipping option for specified seller.
     * @param cartKey The cart key related to the cart.
     * @param body (optional) The shipping option to set for the seller package.
     * @return Cart shipping option successfully set.
     */
    setPackageShippingOption(cartKey: string, body: PackageShippingOption | undefined): Promise<ApiResult>;
    /**
     * Sets a cart's shipping address.
     * @param cartKey Cart key of the cart to modify.
     * @param body (optional) Address information to use.
     * @return Cart shipping address successfully set.
     */
    setShippingAddress(cartKey: string, body: Address | undefined): Promise<void>;
    /**
     * Gets the cart key specified by the externalUserId.
     * @param externalUserId (optional) The external Id of the user we are getting the cart key for.
     * @param sellerKey (optional) Key of the specified seller.
     * @return Cart key for the specified externalUserId.
     */
    getCartKey(externalUserId: string | undefined, sellerKey: string | undefined): Promise<StringApiResult>;
    /**
     * Gets the number of items in a cart.
     * @param cartKey Cart key of the cart to get the item count of
     * @return Cart item count
     */
    getCartCount(cartKey: string): Promise<CartCountSummaryApiResult>;
    /**
     * Gets a summary of a cart with a per-seller breakdown.
     * @param cartKey Cart key of the cart to get the summary for
     * @param countryCode (optional) (Optional) Selected shipping country code (two-letter) of the user.
     * @param includeTaxes (optional) When true, sales tax will be calculated and returned with the response.
    The cart shipping address will also be returned.
     * @return A summary of the cart's items and cost
     */
    getCartSummary(cartKey: string, countryCode: string | undefined, includeTaxes: boolean | undefined): Promise<CartSummaryApiResult>;
    /**
     * Removes a cart's summary from cache.  If the cart is expired or does not exist, no error will be produced.
     * @param cartKey Cart key of cart that should be removed from cache
     * @return Empty response on success
     */
    invalidateCartSummaryCache(cartKey: string): Promise<void>;
    /**
     * Gets user data of the owner of a cart based on a given cart key.
     * @param cartKey Cart key of the cart to get the owner of
     * @return User data of the owner of the cart.
     */
    getCartOwner(cartKey: string): Promise<UserSummaryApiResult>;
    /**
     * Gets the meta data summary of the given cart.
    Such as: is this cart optimized?  What was the previous cart?
    What are this cart's shipping options?
     * @param cartKey Cart key of the cart to get the meta data of.
     * @return Meta data about the cart.
     */
    getCartMeta(cartKey: string): Promise<CartMetaResponseApiResult>;
    /**
     * Checks the inventory status of all the items in the cart associated with the given cart key.
    Returns the status for each, including current seller inventory and price.
    Updates the Cart SQL cached values of IsDirect, AvailableQuantity, and CurrentPrice on each cart item.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param countryCode (optional) The optional country code of the user.
     * @param validateForCheckout (optional) Whether we are validating this cart for checkout.
     * @return CartApi.Models.CartValidation.ValidationResponse, a list of all items in the cart with statuses, updated inventory, and prices.
     */
    validateCart(cartKey: string, countryCode: string | undefined, validateForCheckout: boolean | undefined): Promise<ValidationResponseApiResult>;
    /**
     * Validates the contents of a cart and moves invalid items to the user's Save For Later list.
     * @param saveForLaterKey (optional) 
     * @param countryCode (optional) 
     * @param validateForCheckout (optional) 
     * @return Success
     */
    validateCartAndAutoSaveForLater(cartKey: string, saveForLaterKey: string | undefined, countryCode: string | undefined, validateForCheckout: boolean | undefined): Promise<CartValidationResultApiResult>;
    /**
     * When a user is signing out, this expires their cart if necessary.
     * @param cartKey Key of the cart to clean up
     * @return Success
     */
    cleanUp(cartKey: string): Promise<void>;
    /**
     * Adds a new gift card to a cart
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the gift card to add to the cart.
     * @return CartApi.Models.GiftCards.AddGiftCardResponse containing information about the result of the operation.
     */
    addGiftCard(cartKey: string, body: GiftCardRequest | undefined): Promise<AddGiftCardResponseApiResult>;
    /**
     * Get data for an existing gift card in a cart.
     * @param cartKey The cart key associated with the Cart to get.
     * @param giftCardKey The key associated with the gift card we are getting data for.
     * @return CartApi.Models.GiftCards.GiftCardData containing information about the gift card.
     */
    getGiftCard(cartKey: string, giftCardKey: string): Promise<GiftCardDataApiResult>;
    /**
     * Updates an existing gift card in a cart.
     * @param cartKey The cart key associated with the Cart to get.
     * @param giftCardKey The key associated with the gift card being edited.
     * @param body (optional) Contains information about the gift card in the cart to be edited.
     * @return System.Boolean telling whether the edit was successful or not.
     */
    updateGiftCard(cartKey: string, giftCardKey: string, body: GiftCardRequest | undefined): Promise<BooleanApiResult>;
    /**
     * Adds cards to the cart given their card names / sets / printing / condition parameters.
    Attempts to bundle to the fewest possible packages by preferring Direct.
     * @param body (optional) an object containing the information to add mass entry items to a user's cart.
     * @return CartApi.Models.MassEntry.MassEntryAddToCartResponse
     */
    massEntryAddToCart(body: MassEntryAddToCartRequest | undefined): Promise<MassEntryAddToCartResponseApiResult>;
    /**
     * Identical to M:CartApi.Controllers.MassEntryController.AddToCart(CartApi.Models.MassEntry.MassEntryAddToCartRequest) but includes the added items in the response.
     * @param body (optional) an object containing the information to add mass entry items to a user's cart.
     * @return CartApi.Models.MassEntry.MassEntryAddToCartResponse
     */
    massEntryAddToCartAndRetrieve(body: MassEntryAddToCartRequest | undefined): Promise<MassEntryAddToCartResponseApiResult>;
    /**
     * Adds cards to the cart given a list of skus.
    Attempts to bundle to the fewest possible packages by preferring Direct.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) an object containing the skus to add to the cart.
     * @return CartApi.Models.MassEntry.BulkAddSkusToCartResponse
     */
    bulkAddSkusToCart(cartKey: string, body: BulkAddSkusToCartRequest | undefined): Promise<BulkAddSkusToCartResponseApiResult>;
    /**
     * Loads mass entry data from cache.
     * @param dataId The ID associated with the cached data.
     * @return Mass Entry card data.
     */
    massEntryLoadData(dataId: string): Promise<StringApiResult>;
    /**
     * Validates that the products exist in the catalog.
     * @param categoryId (optional) The Id of the category to validate against.
     * @param body (optional) The products to validate.
     * @return Success
     */
    validateProductsInCatalog(categoryId: number | undefined, body: MassEntryProduct[] | undefined): Promise<MassEntryInputError[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    bulkAddToCart(body: BulkAddToCartRequest | undefined): Promise<BulkAddToCartResponseApiResult>;
    /**
     * After logging in, reconcile the user's active cart in the database with the cart indicated
    by the cart cookie.  Reconciliation can involve moving/copying items, taking ownership of
    carts, or doing nothing.
     * @param externalUserId (optional) The external user id of the user logging in
     * @param cartKey (optional) The cart key taken from the cart cookie, if present, before login
     * @param sellerKey (optional) Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
    marketplace cart omits this value.  In-context carts for a specific seller's Pro site
    have that seller's key provided.
     * @return The user's active cart key
     */
    reconcileCart(externalUserId: string | undefined, cartKey: string | undefined, sellerKey: string | undefined): Promise<StringApiResult>;
    /**
     * Changes a user's active cart by expiring the previous cart and unexpiring the new cart.
    This will not modify the cart key cookie; it only modifies data in the database.
     * @param prevCartKey (optional) Cart key of the user's current cart
     * @param newCartKey (optional) Cart key of the cart that should be active for the user after the swap
     * @param cartOptimizeId (optional) Id of the cart optimization associated with the cart swapping
     * @return Empty response on success or error message on error
     */
    swapActiveCart(prevCartKey: string | undefined, newCartKey: string | undefined, cartOptimizeId: number | undefined): Promise<void>;
}

export class CartClient implements ICartClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Creates a new cart for a user who is not logged in.
     * @param sellerKey (optional) Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
    marketplace cart omits this value.  In-context carts for a specific seller's Pro site
    have that seller's key provided.
     * @return Cart key of the created cart
     */
    createAnonymousCart(sellerKey: string | undefined, cancelToken?: CancelToken): Promise<CreatedCartKeyApiResult> {
        let url_ = this.baseUrl + "/v1/create/anonymouscart?";
        if (sellerKey === null)
            throw new Error("The parameter 'sellerKey' cannot be null.");
        else if (sellerKey !== undefined)
            url_ += "sellerKey=" + encodeURIComponent("" + sellerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAnonymousCart(_response);
        });
    }

    protected processCreateAnonymousCart(response: AxiosResponse): Promise<CreatedCartKeyApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatedCartKeyApiResult.fromJS(resultData200);
            return Promise.resolve<CreatedCartKeyApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CreatedCartKeyApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Creates a new cart belonging to the specified user.
     * @param body (optional) Request containing create parameters
     * @return Cart key of the created cart
     */
    createUserCart(body: CreateCartRequest | undefined, cancelToken?: CancelToken): Promise<CreatedCartKeyApiResult> {
        let url_ = this.baseUrl + "/v1/create/usercart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUserCart(_response);
        });
    }

    protected processCreateUserCart(response: AxiosResponse): Promise<CreatedCartKeyApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatedCartKeyApiResult.fromJS(resultData200);
            return Promise.resolve<CreatedCartKeyApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CreatedCartKeyApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Creates a new cart belonging to the specified user.
     * @param body (optional) Request containing create parameters
     * @return Cart key of the created cart
     */
    createCartOptimizerCart(body: CreateCartOptimizerCartRequest | undefined, cancelToken?: CancelToken): Promise<CreatedCartKeyApiResult> {
        let url_ = this.baseUrl + "/v1/create/createCartOptimizerCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCartOptimizerCart(_response);
        });
    }

    protected processCreateCartOptimizerCart(response: AxiosResponse): Promise<CreatedCartKeyApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatedCartKeyApiResult.fromJS(resultData200);
            return Promise.resolve<CreatedCartKeyApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CreatedCartKeyApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Clears the cart and deletes the cookie associated to it.
     * @param cartKey The key of the cart to clear.
     * @param orderId The order id
     * @return The key of the cart to clear.
     */
    clearCart(cartKey: string, orderId: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/create/{cartKey}/clear/{orderId}";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds a new item to a cart, or increases an existing cart item's requested quantity.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the item to add to the cart.
     * @return CartApi.Models.CartItems.AddItemResponse containing information about the result of the operation.
     */
    addItem(cartKey: string, body: AddItemRequest | undefined, cancelToken?: CancelToken): Promise<AddItemResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/item/add";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddItem(_response);
        });
    }

    protected processAddItem(response: AxiosResponse): Promise<AddItemResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AddItemResponseApiResult.fromJS(resultData200);
            return Promise.resolve<AddItemResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = AddItemResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete a single item from a cart.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param cartItemId The id of the cart item to delete.
     * @return Success.
     */
    deleteItem(cartKey: string, cartItemId: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/{cartKey}/item/{cartItemId}";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (cartItemId === undefined || cartItemId === null)
            throw new Error("The parameter 'cartItemId' must be defined.");
        url_ = url_.replace("{cartItemId}", encodeURIComponent("" + cartItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteItem(_response);
        });
    }

    protected processDeleteItem(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the quantity for a single item from a cart.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param cartItemId The id of the cart item to update.
     * @param body (optional) The new amount to set the requested quantity to.
     * @return Success.
     */
    updateItem(cartKey: string, cartItemId: number, body: UpdateItemRequest | undefined, cancelToken?: CancelToken): Promise<UpdateItemResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/item/{cartItemId}/update";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (cartItemId === undefined || cartItemId === null)
            throw new Error("The parameter 'cartItemId' must be defined.");
        url_ = url_.replace("{cartItemId}", encodeURIComponent("" + cartItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateItem(_response);
        });
    }

    protected processUpdateItem(response: AxiosResponse): Promise<UpdateItemResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateItemResponseApiResult.fromJS(resultData200);
            return Promise.resolve<UpdateItemResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UpdateItemResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets a list of all the items in the cart associated with the given cart key.
     * @param cartKey The dbo.Cart.CartKey of the cart related to the list of cart items being requested.
     * @return A list of all the items in the cart associated with the given cart key.
     */
    getAllItems(cartKey: string, cancelToken?: CancelToken): Promise<CartItemResponseListApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/items";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllItems(_response);
        });
    }

    protected processGetAllItems(response: AxiosResponse): Promise<CartItemResponseListApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CartItemResponseListApiResult.fromJS(resultData200);
            return Promise.resolve<CartItemResponseListApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CartItemResponseListApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Adds items to a cart in bulk.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the items to add to the cart.
     * @return CartApi.Models.CartItems.BulkAddItemsResponse containing information about the result of the operation.
     */
    bulkAddItems(cartKey: string, body: BulkAddItemsRequest | undefined, cancelToken?: CancelToken): Promise<BulkAddItemsResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/items/bulkadd";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkAddItems(_response);
        });
    }

    protected processBulkAddItems(response: AxiosResponse): Promise<BulkAddItemsResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BulkAddItemsResponseApiResult.fromJS(resultData200);
            return Promise.resolve<BulkAddItemsResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = BulkAddItemsResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete items from the cart in bulk.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param body (optional) The list of items to delete from the cart.
     * @return Success.
     */
    bulkDeleteItems(cartKey: string, body: BulkDeleteItemsRequest | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/{cartKey}/items/bulkdelete";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkDeleteItems(_response);
        });
    }

    protected processBulkDeleteItems(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete all items from a cart (clear the cart).
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @return Success.
     */
    deleteAllItems(cartKey: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/{cartKey}/items/all";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllItems(_response);
        });
    }

    protected processDeleteAllItems(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Updates items in a cart in bulk.
     * @param cartKey The cart key associated with the Cart to modify.
     * @param body (optional) Contains information about the items to modify in the cart.
     * @return CartApi.Models.CartItems.BulkUpdateItemsResponse containing information about the result of the operation.
     */
    bulkUpdateItems(cartKey: string, body: BulkUpdateItemsRequest | undefined, cancelToken?: CancelToken): Promise<BulkUpdateItemsResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/items/bulkupdate";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkUpdateItems(_response);
        });
    }

    protected processBulkUpdateItems(response: AxiosResponse): Promise<BulkUpdateItemsResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BulkUpdateItemsResponseApiResult.fromJS(resultData200);
            return Promise.resolve<BulkUpdateItemsResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = BulkUpdateItemsResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Adds items to Save for Later while removing them from a cart
     * @param body (optional) A request object describing the cart items to move and to where
     * @return Success
     */
    moveToSaveForLater(body: MoveToSaveForLaterRequest | undefined, cancelToken?: CancelToken): Promise<MoveToSaveForLaterResultApiResult> {
        let url_ = this.baseUrl + "/v1/cart/movetosaveforlater";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMoveToSaveForLater(_response);
        });
    }

    protected processMoveToSaveForLater(response: AxiosResponse): Promise<MoveToSaveForLaterResultApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MoveToSaveForLaterResultApiResult.fromJS(resultData200);
            return Promise.resolve<MoveToSaveForLaterResultApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = MoveToSaveForLaterResultApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Adds a listo to a cart
     * @param cartKey Key of the cart to modify
     * @param body (optional) Contains information about the listo to add to the cart
     * @return Results of adding the listo
     */
    addListo(cartKey: string, body: AddListoRequest | undefined, cancelToken?: CancelToken): Promise<AddListoResultApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/listo/add";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddListo(_response);
        });
    }

    protected processAddListo(response: AxiosResponse): Promise<AddListoResultApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AddListoResultApiResult.fromJS(resultData200);
            return Promise.resolve<AddListoResultApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = AddListoResultApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Remove cart shipping address (typically used for a guest user).
     * @param cartKey Cart key of cart the shipping address is being removed from.
     * @return Cart shipping address successfully removed.
     */
    removeShippingAddress(cartKey: string, cancelToken?: CancelToken): Promise<ApiResult> {
        let url_ = this.baseUrl + "/v1/CartShipping/{cartKey}/removeshippingaddress";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveShippingAddress(_response);
        });
    }

    protected processRemoveShippingAddress(response: AxiosResponse): Promise<ApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResult.fromJS(resultData200);
            return Promise.resolve<ApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the Cart's selected shipping options.
     * @param cartKey The key associated with the cart.
     * @return Success
     */
    getSelectedShippingOptions(cartKey: string, cancelToken?: CancelToken): Promise<SavedVendorShippingOption[]> {
        let url_ = this.baseUrl + "/v1/CartShipping/{cartKey}/getselectedoptions";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSelectedShippingOptions(_response);
        });
    }

    protected processGetSelectedShippingOptions(response: AxiosResponse): Promise<SavedVendorShippingOption[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SavedVendorShippingOption.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SavedVendorShippingOption[]>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            if (Array.isArray(resultDatadefault)) {
                resultdefault = [] as any;
                for (let item of resultDatadefault)
                    resultdefault!.push(SavedVendorShippingOption.fromJS(item));
            }
            else {
                resultdefault = <any>null;
            }
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Update cart package shipping option for specified seller.
     * @param cartKey The cart key related to the cart.
     * @param body (optional) The shipping option to set for the seller package.
     * @return Cart shipping option successfully set.
     */
    setPackageShippingOption(cartKey: string, body: PackageShippingOption | undefined, cancelToken?: CancelToken): Promise<ApiResult> {
        let url_ = this.baseUrl + "/v1/CartShipping/{cartKey}/setoption";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetPackageShippingOption(_response);
        });
    }

    protected processSetPackageShippingOption(response: AxiosResponse): Promise<ApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiResult.fromJS(resultData200);
            return Promise.resolve<ApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Sets a cart's shipping address.
     * @param cartKey Cart key of the cart to modify.
     * @param body (optional) Address information to use.
     * @return Cart shipping address successfully set.
     */
    setShippingAddress(cartKey: string, body: Address | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/CartShipping/{cartKey}/setshippingaddress";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSetShippingAddress(_response);
        });
    }

    protected processSetShippingAddress(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets the cart key specified by the externalUserId.
     * @param externalUserId (optional) The external Id of the user we are getting the cart key for.
     * @param sellerKey (optional) Key of the specified seller.
     * @return Cart key for the specified externalUserId.
     */
    getCartKey(externalUserId: string | undefined, sellerKey: string | undefined, cancelToken?: CancelToken): Promise<StringApiResult> {
        let url_ = this.baseUrl + "/v1/summary/cartkey?";
        if (externalUserId === null)
            throw new Error("The parameter 'externalUserId' cannot be null.");
        else if (externalUserId !== undefined)
            url_ += "externalUserId=" + encodeURIComponent("" + externalUserId) + "&";
        if (sellerKey === null)
            throw new Error("The parameter 'sellerKey' cannot be null.");
        else if (sellerKey !== undefined)
            url_ += "sellerKey=" + encodeURIComponent("" + sellerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCartKey(_response);
        });
    }

    protected processGetCartKey(response: AxiosResponse): Promise<StringApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResult.fromJS(resultData200);
            return Promise.resolve<StringApiResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = StringApiResult.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResult>(null as any);
    }

    /**
     * Gets the number of items in a cart.
     * @param cartKey Cart key of the cart to get the item count of
     * @return Cart item count
     */
    getCartCount(cartKey: string, cancelToken?: CancelToken): Promise<CartCountSummaryApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/summary/count";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCartCount(_response);
        });
    }

    protected processGetCartCount(response: AxiosResponse): Promise<CartCountSummaryApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CartCountSummaryApiResult.fromJS(resultData200);
            return Promise.resolve<CartCountSummaryApiResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CartCountSummaryApiResult.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CartCountSummaryApiResult>(null as any);
    }

    /**
     * Gets a summary of a cart with a per-seller breakdown.
     * @param cartKey Cart key of the cart to get the summary for
     * @param countryCode (optional) (Optional) Selected shipping country code (two-letter) of the user.
     * @param includeTaxes (optional) When true, sales tax will be calculated and returned with the response.
    The cart shipping address will also be returned.
     * @return A summary of the cart's items and cost
     */
    getCartSummary(cartKey: string, countryCode: string | undefined, includeTaxes: boolean | undefined, cancelToken?: CancelToken): Promise<CartSummaryApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/summary?";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (countryCode === null)
            throw new Error("The parameter 'countryCode' cannot be null.");
        else if (countryCode !== undefined)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (includeTaxes === null)
            throw new Error("The parameter 'includeTaxes' cannot be null.");
        else if (includeTaxes !== undefined)
            url_ += "includeTaxes=" + encodeURIComponent("" + includeTaxes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCartSummary(_response);
        });
    }

    protected processGetCartSummary(response: AxiosResponse): Promise<CartSummaryApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CartSummaryApiResult.fromJS(resultData200);
            return Promise.resolve<CartSummaryApiResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = CartSummaryApiResult.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CartSummaryApiResult>(null as any);
    }

    /**
     * Removes a cart's summary from cache.  If the cart is expired or does not exist, no error will be produced.
     * @param cartKey Cart key of cart that should be removed from cache
     * @return Empty response on success
     */
    invalidateCartSummaryCache(cartKey: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/{cartKey}/summary/invalidate-cache";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInvalidateCartSummaryCache(_response);
        });
    }

    protected processInvalidateCartSummaryCache(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets user data of the owner of a cart based on a given cart key.
     * @param cartKey Cart key of the cart to get the owner of
     * @return User data of the owner of the cart.
     */
    getCartOwner(cartKey: string, cancelToken?: CancelToken): Promise<UserSummaryApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/cartowner";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCartOwner(_response);
        });
    }

    protected processGetCartOwner(response: AxiosResponse): Promise<UserSummaryApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserSummaryApiResult.fromJS(resultData200);
            return Promise.resolve<UserSummaryApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = UserSummaryApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Gets the meta data summary of the given cart.
    Such as: is this cart optimized?  What was the previous cart?
    What are this cart's shipping options?
     * @param cartKey Cart key of the cart to get the meta data of.
     * @return Meta data about the cart.
     */
    getCartMeta(cartKey: string, cancelToken?: CancelToken): Promise<CartMetaResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/summary/meta";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCartMeta(_response);
        });
    }

    protected processGetCartMeta(response: AxiosResponse): Promise<CartMetaResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CartMetaResponseApiResult.fromJS(resultData200);
            return Promise.resolve<CartMetaResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CartMetaResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Checks the inventory status of all the items in the cart associated with the given cart key.
    Returns the status for each, including current seller inventory and price.
    Updates the Cart SQL cached values of IsDirect, AvailableQuantity, and CurrentPrice on each cart item.
     * @param cartKey The dbo.Cart.CartKey of the unexpired cart.
     * @param countryCode (optional) The optional country code of the user.
     * @param validateForCheckout (optional) Whether we are validating this cart for checkout.
     * @return CartApi.Models.CartValidation.ValidationResponse, a list of all items in the cart with statuses, updated inventory, and prices.
     */
    validateCart(cartKey: string, countryCode: string | undefined, validateForCheckout: boolean | undefined, cancelToken?: CancelToken): Promise<ValidationResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/validatecart?";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (countryCode === null)
            throw new Error("The parameter 'countryCode' cannot be null.");
        else if (countryCode !== undefined)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (validateForCheckout === null)
            throw new Error("The parameter 'validateForCheckout' cannot be null.");
        else if (validateForCheckout !== undefined)
            url_ += "validateForCheckout=" + encodeURIComponent("" + validateForCheckout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateCart(_response);
        });
    }

    protected processValidateCart(response: AxiosResponse): Promise<ValidationResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ValidationResponseApiResult.fromJS(resultData200);
            return Promise.resolve<ValidationResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ValidationResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Validates the contents of a cart and moves invalid items to the user's Save For Later list.
     * @param saveForLaterKey (optional) 
     * @param countryCode (optional) 
     * @param validateForCheckout (optional) 
     * @return Success
     */
    validateCartAndAutoSaveForLater(cartKey: string, saveForLaterKey: string | undefined, countryCode: string | undefined, validateForCheckout: boolean | undefined, cancelToken?: CancelToken): Promise<CartValidationResultApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/validatecartandautosaveforlater?";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (saveForLaterKey === null)
            throw new Error("The parameter 'saveForLaterKey' cannot be null.");
        else if (saveForLaterKey !== undefined)
            url_ += "saveForLaterKey=" + encodeURIComponent("" + saveForLaterKey) + "&";
        if (countryCode === null)
            throw new Error("The parameter 'countryCode' cannot be null.");
        else if (countryCode !== undefined)
            url_ += "countryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (validateForCheckout === null)
            throw new Error("The parameter 'validateForCheckout' cannot be null.");
        else if (validateForCheckout !== undefined)
            url_ += "validateForCheckout=" + encodeURIComponent("" + validateForCheckout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateCartAndAutoSaveForLater(_response);
        });
    }

    protected processValidateCartAndAutoSaveForLater(response: AxiosResponse): Promise<CartValidationResultApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CartValidationResultApiResult.fromJS(resultData200);
            return Promise.resolve<CartValidationResultApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = CartValidationResultApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * When a user is signing out, this expires their cart if necessary.
     * @param cartKey Key of the cart to clean up
     * @return Success
     */
    cleanUp(cartKey: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/{cartKey}/cleanup";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCleanUp(_response);
        });
    }

    protected processCleanUp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Adds a new gift card to a cart
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) Contains information about the gift card to add to the cart.
     * @return CartApi.Models.GiftCards.AddGiftCardResponse containing information about the result of the operation.
     */
    addGiftCard(cartKey: string, body: GiftCardRequest | undefined, cancelToken?: CancelToken): Promise<AddGiftCardResponseApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/giftcard/add";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddGiftCard(_response);
        });
    }

    protected processAddGiftCard(response: AxiosResponse): Promise<AddGiftCardResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AddGiftCardResponseApiResult.fromJS(resultData200);
            return Promise.resolve<AddGiftCardResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = AddGiftCardResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get data for an existing gift card in a cart.
     * @param cartKey The cart key associated with the Cart to get.
     * @param giftCardKey The key associated with the gift card we are getting data for.
     * @return CartApi.Models.GiftCards.GiftCardData containing information about the gift card.
     */
    getGiftCard(cartKey: string, giftCardKey: string, cancelToken?: CancelToken): Promise<GiftCardDataApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/giftcard/{giftCardKey}";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (giftCardKey === undefined || giftCardKey === null)
            throw new Error("The parameter 'giftCardKey' must be defined.");
        url_ = url_.replace("{giftCardKey}", encodeURIComponent("" + giftCardKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGiftCard(_response);
        });
    }

    protected processGetGiftCard(response: AxiosResponse): Promise<GiftCardDataApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GiftCardDataApiResult.fromJS(resultData200);
            return Promise.resolve<GiftCardDataApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = GiftCardDataApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Updates an existing gift card in a cart.
     * @param cartKey The cart key associated with the Cart to get.
     * @param giftCardKey The key associated with the gift card being edited.
     * @param body (optional) Contains information about the gift card in the cart to be edited.
     * @return System.Boolean telling whether the edit was successful or not.
     */
    updateGiftCard(cartKey: string, giftCardKey: string, body: GiftCardRequest | undefined, cancelToken?: CancelToken): Promise<BooleanApiResult> {
        let url_ = this.baseUrl + "/v1/{cartKey}/giftcard/{giftCardKey}";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        if (giftCardKey === undefined || giftCardKey === null)
            throw new Error("The parameter 'giftCardKey' must be defined.");
        url_ = url_.replace("{giftCardKey}", encodeURIComponent("" + giftCardKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateGiftCard(_response);
        });
    }

    protected processUpdateGiftCard(response: AxiosResponse): Promise<BooleanApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanApiResult.fromJS(resultData200);
            return Promise.resolve<BooleanApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = BooleanApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Adds cards to the cart given their card names / sets / printing / condition parameters.
    Attempts to bundle to the fewest possible packages by preferring Direct.
     * @param body (optional) an object containing the information to add mass entry items to a user's cart.
     * @return CartApi.Models.MassEntry.MassEntryAddToCartResponse
     */
    massEntryAddToCart(body: MassEntryAddToCartRequest | undefined, cancelToken?: CancelToken): Promise<MassEntryAddToCartResponseApiResult> {
        let url_ = this.baseUrl + "/v1/MassEntry/addToCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMassEntryAddToCart(_response);
        });
    }

    protected processMassEntryAddToCart(response: AxiosResponse): Promise<MassEntryAddToCartResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MassEntryAddToCartResponseApiResult.fromJS(resultData200);
            return Promise.resolve<MassEntryAddToCartResponseApiResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MassEntryAddToCartResponseApiResult>(null as any);
    }

    /**
     * Identical to M:CartApi.Controllers.MassEntryController.AddToCart(CartApi.Models.MassEntry.MassEntryAddToCartRequest) but includes the added items in the response.
     * @param body (optional) an object containing the information to add mass entry items to a user's cart.
     * @return CartApi.Models.MassEntry.MassEntryAddToCartResponse
     */
    massEntryAddToCartAndRetrieve(body: MassEntryAddToCartRequest | undefined, cancelToken?: CancelToken): Promise<MassEntryAddToCartResponseApiResult> {
        let url_ = this.baseUrl + "/v1/MassEntry/addToCartAndRetrieve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMassEntryAddToCartAndRetrieve(_response);
        });
    }

    protected processMassEntryAddToCartAndRetrieve(response: AxiosResponse): Promise<MassEntryAddToCartResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MassEntryAddToCartResponseApiResult.fromJS(resultData200);
            return Promise.resolve<MassEntryAddToCartResponseApiResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MassEntryAddToCartResponseApiResult>(null as any);
    }

    /**
     * Adds cards to the cart given a list of skus.
    Attempts to bundle to the fewest possible packages by preferring Direct.
     * @param cartKey The cart key associated with the Cart to get.
     * @param body (optional) an object containing the skus to add to the cart.
     * @return CartApi.Models.MassEntry.BulkAddSkusToCartResponse
     */
    bulkAddSkusToCart(cartKey: string, body: BulkAddSkusToCartRequest | undefined, cancelToken?: CancelToken): Promise<BulkAddSkusToCartResponseApiResult> {
        let url_ = this.baseUrl + "/v1/MassEntry/{cartKey}/bulkaddskus";
        if (cartKey === undefined || cartKey === null)
            throw new Error("The parameter 'cartKey' must be defined.");
        url_ = url_.replace("{cartKey}", encodeURIComponent("" + cartKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkAddSkusToCart(_response);
        });
    }

    protected processBulkAddSkusToCart(response: AxiosResponse): Promise<BulkAddSkusToCartResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BulkAddSkusToCartResponseApiResult.fromJS(resultData200);
            return Promise.resolve<BulkAddSkusToCartResponseApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = BulkAddSkusToCartResponseApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Loads mass entry data from cache.
     * @param dataId The ID associated with the cached data.
     * @return Mass Entry card data.
     */
    massEntryLoadData(dataId: string, cancelToken?: CancelToken): Promise<StringApiResult> {
        let url_ = this.baseUrl + "/v1/MassEntry/loaddata/{dataId}";
        if (dataId === undefined || dataId === null)
            throw new Error("The parameter 'dataId' must be defined.");
        url_ = url_.replace("{dataId}", encodeURIComponent("" + dataId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMassEntryLoadData(_response);
        });
    }

    protected processMassEntryLoadData(response: AxiosResponse): Promise<StringApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResult.fromJS(resultData200);
            return Promise.resolve<StringApiResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringApiResult>(null as any);
    }

    /**
     * Validates that the products exist in the catalog.
     * @param categoryId (optional) The Id of the category to validate against.
     * @param body (optional) The products to validate.
     * @return Success
     */
    validateProductsInCatalog(categoryId: number | undefined, body: MassEntryProduct[] | undefined, cancelToken?: CancelToken): Promise<MassEntryInputError[]> {
        let url_ = this.baseUrl + "/v1/MassEntry/validateproductsincatalog?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processValidateProductsInCatalog(_response);
        });
    }

    protected processValidateProductsInCatalog(response: AxiosResponse): Promise<MassEntryInputError[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MassEntryInputError.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MassEntryInputError[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MassEntryInputError[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkAddToCart(body: BulkAddToCartRequest | undefined, cancelToken?: CancelToken): Promise<BulkAddToCartResponseApiResult> {
        let url_ = this.baseUrl + "/v1/MassEntry/bulkAddToCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBulkAddToCart(_response);
        });
    }

    protected processBulkAddToCart(response: AxiosResponse): Promise<BulkAddToCartResponseApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BulkAddToCartResponseApiResult.fromJS(resultData200);
            return Promise.resolve<BulkAddToCartResponseApiResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BulkAddToCartResponseApiResult>(null as any);
    }

    /**
     * After logging in, reconcile the user's active cart in the database with the cart indicated
    by the cart cookie.  Reconciliation can involve moving/copying items, taking ownership of
    carts, or doing nothing.
     * @param externalUserId (optional) The external user id of the user logging in
     * @param cartKey (optional) The cart key taken from the cart cookie, if present, before login
     * @param sellerKey (optional) Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
    marketplace cart omits this value.  In-context carts for a specific seller's Pro site
    have that seller's key provided.
     * @return The user's active cart key
     */
    reconcileCart(externalUserId: string | undefined, cartKey: string | undefined, sellerKey: string | undefined, cancelToken?: CancelToken): Promise<StringApiResult> {
        let url_ = this.baseUrl + "/v1/reconcilecart?";
        if (externalUserId === null)
            throw new Error("The parameter 'externalUserId' cannot be null.");
        else if (externalUserId !== undefined)
            url_ += "externalUserId=" + encodeURIComponent("" + externalUserId) + "&";
        if (cartKey === null)
            throw new Error("The parameter 'cartKey' cannot be null.");
        else if (cartKey !== undefined)
            url_ += "cartKey=" + encodeURIComponent("" + cartKey) + "&";
        if (sellerKey === null)
            throw new Error("The parameter 'sellerKey' cannot be null.");
        else if (sellerKey !== undefined)
            url_ += "sellerKey=" + encodeURIComponent("" + sellerKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconcileCart(_response);
        });
    }

    protected processReconcileCart(response: AxiosResponse): Promise<StringApiResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StringApiResult.fromJS(resultData200);
            return Promise.resolve<StringApiResult>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = StringApiResult.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Changes a user's active cart by expiring the previous cart and unexpiring the new cart.
    This will not modify the cart key cookie; it only modifies data in the database.
     * @param prevCartKey (optional) Cart key of the user's current cart
     * @param newCartKey (optional) Cart key of the cart that should be active for the user after the swap
     * @param cartOptimizeId (optional) Id of the cart optimization associated with the cart swapping
     * @return Empty response on success or error message on error
     */
    swapActiveCart(prevCartKey: string | undefined, newCartKey: string | undefined, cartOptimizeId: number | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/v1/SwapCart/SwapActiveCart?";
        if (prevCartKey === null)
            throw new Error("The parameter 'prevCartKey' cannot be null.");
        else if (prevCartKey !== undefined)
            url_ += "prevCartKey=" + encodeURIComponent("" + prevCartKey) + "&";
        if (newCartKey === null)
            throw new Error("The parameter 'newCartKey' cannot be null.");
        else if (newCartKey !== undefined)
            url_ += "newCartKey=" + encodeURIComponent("" + newCartKey) + "&";
        if (cartOptimizeId === null)
            throw new Error("The parameter 'cartOptimizeId' cannot be null.");
        else if (cartOptimizeId !== undefined)
            url_ += "cartOptimizeId=" + encodeURIComponent("" + cartOptimizeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSwapActiveCart(_response);
        });
    }

    protected processSwapActiveCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

/** The error codes, including descriptions. */
export enum ErrorCodes_Code {
    Success = "Success",
    InvalidRequest = "InvalidRequest",
    CartItemQuantityInvalid = "CartItemQuantityInvalid",
    CartNotFound = "CartNotFound",
    CartItemQuantityNotAvailable = "CartItemQuantityNotAvailable",
    CartItemNotDeleted = "CartItemNotDeleted",
    CartItemNotFound = "CartItemNotFound",
    MassEntryEmptyInput = "MassEntryEmptyInput",
    MassEntryInvalidInput = "MassEntryInvalidInput",
    MassEntryListingsNotFound = "MassEntryListingsNotFound",
    MassEntryAddToCartFailure = "MassEntryAddToCartFailure",
    CartShippingOptionNotUpdated = "CartShippingOptionNotUpdated",
    CartAccessDenied = "CartAccessDenied",
    SellerOffline = "SellerOffline",
    CartExpired = "CartExpired",
    SellerNotFound = "SellerNotFound",
    UserNotFound = "UserNotFound",
    ProductNotFound = "ProductNotFound",
    InvalidGiftCardTemplateId = "InvalidGiftCardTemplateId",
    InvalidGiftCardAmount = "InvalidGiftCardAmount",
    InvalidGiftCardName = "InvalidGiftCardName",
    InvalidGiftCardAddress = "InvalidGiftCardAddress",
    InvalidGiftCardMessage = "InvalidGiftCardMessage",
    BulkAddItemsFailure = "BulkAddItemsFailure",
    GiftCardNotFound = "GiftCardNotFound",
    DirectInventoryNotAvailable = "DirectInventoryNotAvailable",
    SealedShippingRestriction = "SealedShippingRestriction",
    SellerCannotShip = "SellerCannotShip",
    InvalidGiftCardDeliveryDate = "InvalidGiftCardDeliveryDate",
    CartShippingOptionInvalid = "CartShippingOptionInvalid",
    BulkUpdateItemsFailure = "BulkUpdateItemsFailure",
    CartShippingAddressNotUpdated = "CartShippingAddressNotUpdated",
    CartPackageShippingOptionNotUpdated = "CartPackageShippingOptionNotUpdated",
    ShippingSellerPriceNotFound = "ShippingSellerPriceNotFound",
    TooManyItems = "TooManyItems",
    ProductCategoryNotVisible = "ProductCategoryNotVisible",
    CartCustomListingNotAvailable = "CartCustomListingNotAvailable",
    BuyerBlockedBySeller = "BuyerBlockedBySeller",
    CartShippingOptionUnavailable = "CartShippingOptionUnavailable",
    CartShippingOptionMismatch = "CartShippingOptionMismatch",
    CartShippingAddressMissing = "CartShippingAddressMissing",
    CartUserMissing = "CartUserMissing",
    MissingShippingOption = "MissingShippingOption",
    TaxError = "TaxError",
}

export class Address implements IAddress {
    addressBookId!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    line1!: string | undefined;
    line2!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    zipcode!: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressBookId = _data["addressBookId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.zipcode = _data["zipcode"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressBookId"] = this.addressBookId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["zipcode"] = this.zipcode;
        return data;
    }
}

export interface IAddress {
    addressBookId: number;
    firstName: string | undefined;
    lastName: string | undefined;
    line1: string | undefined;
    line2: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    zipcode: string | undefined;
}

/** Summary of the number of items in the cart */
export class CartCountSummary implements ICartCountSummary {
    /** Number of items in the cart */
    itemCount!: number;

    constructor(data?: ICartCountSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemCount = _data["itemCount"];
        }
    }

    static fromJS(data: any): CartCountSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CartCountSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCount"] = this.itemCount;
        return data;
    }
}

/** Summary of the number of items in the cart */
export interface ICartCountSummary {
    /** Number of items in the cart */
    itemCount: number;
}

export class CartCountSummaryApiResult implements ICartCountSummaryApiResult {
    errors!: ApiError[] | undefined;
    results!: CartCountSummary[] | undefined;
    result!: CartCountSummary;

    constructor(data?: ICartCountSummaryApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CartCountSummary.fromJS(item));
            }
            this.result = _data["result"] ? CartCountSummary.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartCountSummaryApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartCountSummaryApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartCountSummaryApiResult {
    errors: ApiError[] | undefined;
    results: CartCountSummary[] | undefined;
    result: CartCountSummary;
}

/** The meta data summary of a cart. */
export class CartMetaResponse implements ICartMetaResponse {
    /** True if this cart was optimized and has not been modified since optimization. */
    isCartOptimized!: boolean;
    /** The user's selected shipping options, if any differ from the default.
TODO: This should be parsed within the API and returned as a nice class to the caller. */
    selectedShippingOptions!: ShippingOption[] | undefined;
    optimizationDetails!: CartMetaResponse_OptimizeCartDetails;

    constructor(data?: ICartMetaResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isCartOptimized = _data["isCartOptimized"];
            if (Array.isArray(_data["selectedShippingOptions"])) {
                this.selectedShippingOptions = [] as any;
                for (let item of _data["selectedShippingOptions"])
                    this.selectedShippingOptions!.push(ShippingOption.fromJS(item));
            }
            this.optimizationDetails = _data["optimizationDetails"] ? CartMetaResponse_OptimizeCartDetails.fromJS(_data["optimizationDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartMetaResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CartMetaResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isCartOptimized"] = this.isCartOptimized;
        if (Array.isArray(this.selectedShippingOptions)) {
            data["selectedShippingOptions"] = [];
            for (let item of this.selectedShippingOptions)
                data["selectedShippingOptions"].push(item.toJSON());
        }
        data["optimizationDetails"] = this.optimizationDetails ? this.optimizationDetails.toJSON() : <any>undefined;
        return data;
    }
}

/** The meta data summary of a cart. */
export interface ICartMetaResponse {
    /** True if this cart was optimized and has not been modified since optimization. */
    isCartOptimized: boolean;
    /** The user's selected shipping options, if any differ from the default.
TODO: This should be parsed within the API and returned as a nice class to the caller. */
    selectedShippingOptions: ShippingOption[] | undefined;
    optimizationDetails: CartMetaResponse_OptimizeCartDetails;
}

export class CartMetaResponseApiResult implements ICartMetaResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: CartMetaResponse[] | undefined;
    result!: CartMetaResponse;

    constructor(data?: ICartMetaResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CartMetaResponse.fromJS(item));
            }
            this.result = _data["result"] ? CartMetaResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartMetaResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartMetaResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartMetaResponseApiResult {
    errors: ApiError[] | undefined;
    results: CartMetaResponse[] | undefined;
    result: CartMetaResponse;
}

/** Details about the cart previous to the optimization. */
export class CartMetaResponse_OptimizeCartDetails implements ICartMetaResponse_OptimizeCartDetails {
    /** The cartKey of the cart before the optimization occurred.  Used to undo the optimization. */
    preOptimizedCartKey!: string | undefined;
    /** The total cost of the pre-optimized cart. */
    preOptimizedTotal!: number;

    constructor(data?: ICartMetaResponse_OptimizeCartDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.preOptimizedCartKey = _data["preOptimizedCartKey"];
            this.preOptimizedTotal = _data["preOptimizedTotal"];
        }
    }

    static fromJS(data: any): CartMetaResponse_OptimizeCartDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CartMetaResponse_OptimizeCartDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["preOptimizedCartKey"] = this.preOptimizedCartKey;
        data["preOptimizedTotal"] = this.preOptimizedTotal;
        return data;
    }
}

/** Details about the cart previous to the optimization. */
export interface ICartMetaResponse_OptimizeCartDetails {
    /** The cartKey of the cart before the optimization occurred.  Used to undo the optimization. */
    preOptimizedCartKey: string | undefined;
    /** The total cost of the pre-optimized cart. */
    preOptimizedTotal: number;
}

/** A summary of the cart's items and cost */
export class CartSummary implements ICartSummary {
    /** Public cart identifier */
    cartKey!: string | undefined;
    /** Total number of items in the cart factoring in quantity */
    itemCount!: number;
    /** Total number of sellers with non-Direct packages, adding in +1 if there is also a Direct package. */
    fulfillerCount!: number;
    /** The total cost of all requested items and quantities */
    requestedTotalCost!: number;
    /** Estimated shipping cost */
    estimatedShippingCost!: number;
    /** Summaries for each seller */
    readonly sellers!: CartSummarySeller[] | undefined;
    /** Gets or sets the total dollar amount of products in the cart. This is the product value only and does
not include tax or shipping. */
    itemSubtotal!: number;
    /** Gets or sets the total dollar amount of products in the cart that are eligible for Direct.
This is the product value only and does not include tax or shipping. */
    directItemSubtotal!: number;
    /** Gets or sets the number of packages that will be shipped. */
    packageCount!: number;
    /** Total number of unique items according to sku, seller and channel. */
    uniqueItemCount!: number;
    /** Gets or sets selected shipping country code (two-letter). */
    selectedCountryCode!: string | undefined;
    shippingAddress!: Address;
    tax!: CartSummaryTax;
    /** The tax invoices for the cart. */
    taxInvoices!: InvoiceTaxes[] | undefined;

    constructor(data?: ICartSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartKey = _data["cartKey"];
            this.itemCount = _data["itemCount"];
            this.fulfillerCount = _data["fulfillerCount"];
            this.requestedTotalCost = _data["requestedTotalCost"];
            this.estimatedShippingCost = _data["estimatedShippingCost"];
            if (Array.isArray(_data["sellers"])) {
                (<any>this).sellers = [] as any;
                for (let item of _data["sellers"])
                    (<any>this).sellers!.push(CartSummarySeller.fromJS(item));
            }
            this.itemSubtotal = _data["itemSubtotal"];
            this.directItemSubtotal = _data["directItemSubtotal"];
            this.packageCount = _data["packageCount"];
            this.uniqueItemCount = _data["uniqueItemCount"];
            this.selectedCountryCode = _data["selectedCountryCode"];
            this.shippingAddress = _data["shippingAddress"] ? Address.fromJS(_data["shippingAddress"]) : <any>undefined;
            this.tax = _data["tax"] ? CartSummaryTax.fromJS(_data["tax"]) : <any>undefined;
            if (Array.isArray(_data["taxInvoices"])) {
                this.taxInvoices = [] as any;
                for (let item of _data["taxInvoices"])
                    this.taxInvoices!.push(InvoiceTaxes.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CartSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartKey"] = this.cartKey;
        data["itemCount"] = this.itemCount;
        data["fulfillerCount"] = this.fulfillerCount;
        data["requestedTotalCost"] = this.requestedTotalCost;
        data["estimatedShippingCost"] = this.estimatedShippingCost;
        if (Array.isArray(this.sellers)) {
            data["sellers"] = [];
            for (let item of this.sellers)
                data["sellers"].push(item.toJSON());
        }
        data["itemSubtotal"] = this.itemSubtotal;
        data["directItemSubtotal"] = this.directItemSubtotal;
        data["packageCount"] = this.packageCount;
        data["uniqueItemCount"] = this.uniqueItemCount;
        data["selectedCountryCode"] = this.selectedCountryCode;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : <any>undefined;
        data["tax"] = this.tax ? this.tax.toJSON() : <any>undefined;
        if (Array.isArray(this.taxInvoices)) {
            data["taxInvoices"] = [];
            for (let item of this.taxInvoices)
                data["taxInvoices"].push(item.toJSON());
        }
        return data;
    }
}

/** A summary of the cart's items and cost */
export interface ICartSummary {
    /** Public cart identifier */
    cartKey: string | undefined;
    /** Total number of items in the cart factoring in quantity */
    itemCount: number;
    /** Total number of sellers with non-Direct packages, adding in +1 if there is also a Direct package. */
    fulfillerCount: number;
    /** The total cost of all requested items and quantities */
    requestedTotalCost: number;
    /** Estimated shipping cost */
    estimatedShippingCost: number;
    /** Summaries for each seller */
    sellers: CartSummarySeller[] | undefined;
    /** Gets or sets the total dollar amount of products in the cart. This is the product value only and does
not include tax or shipping. */
    itemSubtotal: number;
    /** Gets or sets the total dollar amount of products in the cart that are eligible for Direct.
This is the product value only and does not include tax or shipping. */
    directItemSubtotal: number;
    /** Gets or sets the number of packages that will be shipped. */
    packageCount: number;
    /** Total number of unique items according to sku, seller and channel. */
    uniqueItemCount: number;
    /** Gets or sets selected shipping country code (two-letter). */
    selectedCountryCode: string | undefined;
    shippingAddress: Address;
    tax: CartSummaryTax;
    /** The tax invoices for the cart. */
    taxInvoices: InvoiceTaxes[] | undefined;
}

export class CartSummaryApiResult implements ICartSummaryApiResult {
    errors!: ApiError[] | undefined;
    results!: CartSummary[] | undefined;
    result!: CartSummary;

    constructor(data?: ICartSummaryApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CartSummary.fromJS(item));
            }
            this.result = _data["result"] ? CartSummary.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartSummaryApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummaryApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartSummaryApiResult {
    errors: ApiError[] | undefined;
    results: CartSummary[] | undefined;
    result: CartSummary;
}

/** A summary of the cart's items for a single seller */
export class CartSummarySeller implements ICartSummarySeller {
    /** Public seller identifier */
    sellerKey!: string | undefined;
    /** The total cost of all requested items from this seller */
    productTotalCost!: number;
    /** The shipping cost for just this seller */
    shippingCost!: number;
    /** The tax amount for this seller package */
    salesTax!: number | undefined;

    constructor(data?: ICartSummarySeller) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerKey = _data["sellerKey"];
            this.productTotalCost = _data["productTotalCost"];
            this.shippingCost = _data["shippingCost"];
            this.salesTax = _data["salesTax"];
        }
    }

    static fromJS(data: any): CartSummarySeller {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummarySeller();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerKey"] = this.sellerKey;
        data["productTotalCost"] = this.productTotalCost;
        data["shippingCost"] = this.shippingCost;
        data["salesTax"] = this.salesTax;
        return data;
    }
}

/** A summary of the cart's items for a single seller */
export interface ICartSummarySeller {
    /** Public seller identifier */
    sellerKey: string | undefined;
    /** The total cost of all requested items from this seller */
    productTotalCost: number;
    /** The shipping cost for just this seller */
    shippingCost: number;
    /** The tax amount for this seller package */
    salesTax: number | undefined;
}

export class CartSummaryTax implements ICartSummaryTax {
    /** The sales tax for the Direct package. */
    directSalesTax!: number | undefined;
    /** The total sales tax for the cart. */
    totalSalesTax!: number | undefined;
    /** Individual tax elements to display to the user. */
    displayElements!: { [key: string]: number; } | undefined;

    constructor(data?: ICartSummaryTax) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.directSalesTax = _data["directSalesTax"];
            this.totalSalesTax = _data["totalSalesTax"];
            if (_data["displayElements"]) {
                this.displayElements = {} as any;
                for (let key in _data["displayElements"]) {
                    if (_data["displayElements"].hasOwnProperty(key))
                        (<any>this.displayElements)![key] = _data["displayElements"][key];
                }
            }
        }
    }

    static fromJS(data: any): CartSummaryTax {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummaryTax();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["directSalesTax"] = this.directSalesTax;
        data["totalSalesTax"] = this.totalSalesTax;
        if (this.displayElements) {
            data["displayElements"] = {};
            for (let key in this.displayElements) {
                if (this.displayElements.hasOwnProperty(key))
                    (<any>data["displayElements"])[key] = (<any>this.displayElements)[key];
            }
        }
        return data;
    }
}

export interface ICartSummaryTax {
    /** The sales tax for the Direct package. */
    directSalesTax: number | undefined;
    /** The total sales tax for the cart. */
    totalSalesTax: number | undefined;
    /** Individual tax elements to display to the user. */
    displayElements: { [key: string]: number; } | undefined;
}

/** Request to create an optimized cart owned by a user */
export class CreateCartOptimizerCartRequest implements ICreateCartOptimizerCartRequest {
    /** The cart optimization id */
    cartOptimizeId!: number;
    /** The cart optimization type id (Direct (1), Verified (2), Any (3) */
    cartOptimizeTypeId!: number;
    /** Cart key of the cart being optimized against */
    preCartKey!: string | undefined;
    /** Items that were never selected to be optimized, such as sealed products or unchecked products */
    nonOptimizedCartItems!: number[] | undefined;

    constructor(data?: ICreateCartOptimizerCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartOptimizeId = _data["cartOptimizeId"];
            this.cartOptimizeTypeId = _data["cartOptimizeTypeId"];
            this.preCartKey = _data["preCartKey"];
            if (Array.isArray(_data["nonOptimizedCartItems"])) {
                this.nonOptimizedCartItems = [] as any;
                for (let item of _data["nonOptimizedCartItems"])
                    this.nonOptimizedCartItems!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCartOptimizerCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCartOptimizerCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartOptimizeId"] = this.cartOptimizeId;
        data["cartOptimizeTypeId"] = this.cartOptimizeTypeId;
        data["preCartKey"] = this.preCartKey;
        if (Array.isArray(this.nonOptimizedCartItems)) {
            data["nonOptimizedCartItems"] = [];
            for (let item of this.nonOptimizedCartItems)
                data["nonOptimizedCartItems"].push(item);
        }
        return data;
    }
}

/** Request to create an optimized cart owned by a user */
export interface ICreateCartOptimizerCartRequest {
    /** The cart optimization id */
    cartOptimizeId: number;
    /** The cart optimization type id (Direct (1), Verified (2), Any (3) */
    cartOptimizeTypeId: number;
    /** Cart key of the cart being optimized against */
    preCartKey: string | undefined;
    /** Items that were never selected to be optimized, such as sealed products or unchecked products */
    nonOptimizedCartItems: number[] | undefined;
}

/** Request to create a cart owned by a user */
export class CreateCartRequest implements ICreateCartRequest {
    /** Publicly visible identifier of the user who should own this cart.  This is not the same as `ProviderUserKey`. */
    externalUserId!: string;
    /** Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
marketplace cart omits this value.  In-context carts for a specific seller's Pro site
have that seller's key provided. */
    sellerKey!: string | undefined;

    constructor(data?: ICreateCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.externalUserId = _data["externalUserId"];
            this.sellerKey = _data["sellerKey"];
        }
    }

    static fromJS(data: any): CreateCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["externalUserId"] = this.externalUserId;
        data["sellerKey"] = this.sellerKey;
        return data;
    }
}

/** Request to create a cart owned by a user */
export interface ICreateCartRequest {
    /** Publicly visible identifier of the user who should own this cart.  This is not the same as `ProviderUserKey`. */
    externalUserId: string;
    /** Seller key of the in-context seller who should be associated with this cart.  A TCGplayer
marketplace cart omits this value.  In-context carts for a specific seller's Pro site
have that seller's key provided. */
    sellerKey: string | undefined;
}

/** The results of creating a cart */
export class CreatedCartKey implements ICreatedCartKey {
    /** Gets or sets the cart key of the created cart */
    cartKey!: string | undefined;

    constructor(data?: ICreatedCartKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartKey = _data["cartKey"];
        }
    }

    static fromJS(data: any): CreatedCartKey {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedCartKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartKey"] = this.cartKey;
        return data;
    }
}

/** The results of creating a cart */
export interface ICreatedCartKey {
    /** Gets or sets the cart key of the created cart */
    cartKey: string | undefined;
}

export class CreatedCartKeyApiResult implements ICreatedCartKeyApiResult {
    errors!: ApiError[] | undefined;
    results!: CreatedCartKey[] | undefined;
    result!: CreatedCartKey;

    constructor(data?: ICreatedCartKeyApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CreatedCartKey.fromJS(item));
            }
            this.result = _data["result"] ? CreatedCartKey.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreatedCartKeyApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedCartKeyApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreatedCartKeyApiResult {
    errors: ApiError[] | undefined;
    results: CreatedCartKey[] | undefined;
    result: CreatedCartKey;
}

export class PackageShippingOption implements IPackageShippingOption {
    sellerId!: number;
    shippingMethodCode!: string | undefined;
    shippingCost!: number;
    shippingCategoryId!: number;
    isOverThreshold!: boolean;
    shippingCountry!: string | undefined;

    constructor(data?: IPackageShippingOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.shippingMethodCode = _data["shippingMethodCode"];
            this.shippingCost = _data["shippingCost"];
            this.shippingCategoryId = _data["shippingCategoryId"];
            this.isOverThreshold = _data["isOverThreshold"];
            this.shippingCountry = _data["shippingCountry"];
        }
    }

    static fromJS(data: any): PackageShippingOption {
        data = typeof data === 'object' ? data : {};
        let result = new PackageShippingOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["shippingMethodCode"] = this.shippingMethodCode;
        data["shippingCost"] = this.shippingCost;
        data["shippingCategoryId"] = this.shippingCategoryId;
        data["isOverThreshold"] = this.isOverThreshold;
        data["shippingCountry"] = this.shippingCountry;
        return data;
    }
}

export interface IPackageShippingOption {
    sellerId: number;
    shippingMethodCode: string | undefined;
    shippingCost: number;
    shippingCategoryId: number;
    isOverThreshold: boolean;
    shippingCountry: string | undefined;
}

/** Represents a vendor shipping option that the user has saved with their cart. */
export class ShippingOption implements IShippingOption {
    /** The ID of the seller that this shipping option is for.
Seller.TCGDIRECT_SELLER_ID is used for Direct packages. */
    sellerId!: number;
    /** The method key of the shipping method for this seller. */
    shippingMethodCode!: string | undefined;

    constructor(data?: IShippingOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.shippingMethodCode = _data["shippingMethodCode"];
        }
    }

    static fromJS(data: any): ShippingOption {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["shippingMethodCode"] = this.shippingMethodCode;
        return data;
    }
}

/** Represents a vendor shipping option that the user has saved with their cart. */
export interface IShippingOption {
    /** The ID of the seller that this shipping option is for.
Seller.TCGDIRECT_SELLER_ID is used for Direct packages. */
    sellerId: number;
    /** The method key of the shipping method for this seller. */
    shippingMethodCode: string | undefined;
}

/** A class that defines the response envelope for API requests that return an empty body or error messages. */
export class ApiResult implements IApiResult {
    /** Gets a collection of errors associated with an API call */
    readonly errors!: ApiError[] | undefined;

    constructor(data?: IApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(ApiError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

/** A class that defines the response envelope for API requests that return an empty body or error messages. */
export interface IApiResult {
    /** Gets a collection of errors associated with an API call */
    errors: ApiError[] | undefined;
}

/** Represents a request to add a product to a cart. */
export class AddItemRequest implements IAddItemRequest {
    /** The ProductConditionId for this listing. */
    sku!: number;
    /** Seller key of the seller of the item to be added to the cart. */
    sellerKey!: string | undefined;
    /** Seller id of the seller of the item to be added to the cart. */
    sellerId!: number | undefined;
    /** Id of the channel of the item to be added to the cart. */
    channelId!: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity!: number;
    /** Expected price of the product to add to the cart. */
    price!: number | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode!: string | undefined;
    /** Whether the listing is intended to be included in the direct package. */
    isDirect!: boolean;

    constructor(data?: IAddItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.sellerKey = _data["sellerKey"];
            this.sellerId = _data["sellerId"];
            this.channelId = _data["channelId"];
            this.requestedQuantity = _data["requestedQuantity"];
            this.price = _data["price"];
            this.countryCode = _data["countryCode"];
            this.isDirect = _data["isDirect"];
        }
    }

    static fromJS(data: any): AddItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["sellerKey"] = this.sellerKey;
        data["sellerId"] = this.sellerId;
        data["channelId"] = this.channelId;
        data["requestedQuantity"] = this.requestedQuantity;
        data["price"] = this.price;
        data["countryCode"] = this.countryCode;
        data["isDirect"] = this.isDirect;
        return data;
    }
}

/** Represents a request to add a product to a cart. */
export interface IAddItemRequest {
    /** The ProductConditionId for this listing. */
    sku: number;
    /** Seller key of the seller of the item to be added to the cart. */
    sellerKey: string | undefined;
    /** Seller id of the seller of the item to be added to the cart. */
    sellerId: number | undefined;
    /** Id of the channel of the item to be added to the cart. */
    channelId: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity: number;
    /** Expected price of the product to add to the cart. */
    price: number | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode: string | undefined;
    /** Whether the listing is intended to be included in the direct package. */
    isDirect: boolean;
}

/** Represents the result of attempting to add a product to a cart. */
export class AddItemResponse implements IAddItemResponse {
    status!: ErrorCodes_Code;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect!: boolean;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable!: number;
    /** Item quantity that is already in the cart for the desired item. */
    itemQuantityInCart!: number;
    /** Current price of the product. */
    currentPrice!: number;

    constructor(data?: IAddItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.isDirect = _data["isDirect"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            this.itemQuantityInCart = _data["itemQuantityInCart"];
            this.currentPrice = _data["currentPrice"];
        }
    }

    static fromJS(data: any): AddItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["isDirect"] = this.isDirect;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["itemQuantityInCart"] = this.itemQuantityInCart;
        data["currentPrice"] = this.currentPrice;
        return data;
    }
}

/** Represents the result of attempting to add a product to a cart. */
export interface IAddItemResponse {
    status: ErrorCodes_Code;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect: boolean;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable: number;
    /** Item quantity that is already in the cart for the desired item. */
    itemQuantityInCart: number;
    /** Current price of the product. */
    currentPrice: number;
}

export class AddItemResponseApiResult implements IAddItemResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: AddItemResponse[] | undefined;
    result!: AddItemResponse;

    constructor(data?: IAddItemResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AddItemResponse.fromJS(item));
            }
            this.result = _data["result"] ? AddItemResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddItemResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddItemResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddItemResponseApiResult {
    errors: ApiError[] | undefined;
    results: AddItemResponse[] | undefined;
    result: AddItemResponse;
}

/** A request to add a listo to a cart */
export class AddListoRequest implements IAddListoRequest {
    /** The encrypted, public key of the listo */
    customListingKey!: string | undefined;
    /** Channel the listo is being sold through */
    channelId!: number;
    /** Quantity of the listo */
    quantityToBuy!: number;
    /** The price when the listo was added to determine if it changed before the request was made */
    priceAtAdd!: number | undefined;
    /** The buyer's shipping country code. */
    countryCode!: string | undefined;

    constructor(data?: IAddListoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customListingKey = _data["customListingKey"];
            this.channelId = _data["channelId"];
            this.quantityToBuy = _data["quantityToBuy"];
            this.priceAtAdd = _data["priceAtAdd"];
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): AddListoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddListoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customListingKey"] = this.customListingKey;
        data["channelId"] = this.channelId;
        data["quantityToBuy"] = this.quantityToBuy;
        data["priceAtAdd"] = this.priceAtAdd;
        data["countryCode"] = this.countryCode;
        return data;
    }
}

/** A request to add a listo to a cart */
export interface IAddListoRequest {
    /** The encrypted, public key of the listo */
    customListingKey: string | undefined;
    /** Channel the listo is being sold through */
    channelId: number;
    /** Quantity of the listo */
    quantityToBuy: number;
    /** The price when the listo was added to determine if it changed before the request was made */
    priceAtAdd: number | undefined;
    /** The buyer's shipping country code. */
    countryCode: string | undefined;
}

/** The result of adding a listo to a cart. */
export class AddListoResult implements IAddListoResult {
    /** The price of the item when added. */
    currentItemPrice!: number;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable!: number;
    /** Item quantity that is already in the cart for the desired item. */
    itemQuantityInCart!: number;

    constructor(data?: IAddListoResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentItemPrice = _data["currentItemPrice"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            this.itemQuantityInCart = _data["itemQuantityInCart"];
        }
    }

    static fromJS(data: any): AddListoResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddListoResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentItemPrice"] = this.currentItemPrice;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["itemQuantityInCart"] = this.itemQuantityInCart;
        return data;
    }
}

/** The result of adding a listo to a cart. */
export interface IAddListoResult {
    /** The price of the item when added. */
    currentItemPrice: number;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable: number;
    /** Item quantity that is already in the cart for the desired item. */
    itemQuantityInCart: number;
}

export class AddListoResultApiResult implements IAddListoResultApiResult {
    errors!: ApiError[] | undefined;
    results!: AddListoResult[] | undefined;
    result!: AddListoResult;

    constructor(data?: IAddListoResultApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AddListoResult.fromJS(item));
            }
            this.result = _data["result"] ? AddListoResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddListoResultApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddListoResultApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddListoResultApiResult {
    errors: ApiError[] | undefined;
    results: AddListoResult[] | undefined;
    result: AddListoResult;
}

/** Represents a request to add multiple products to a cart. */
export class BulkAddItemsRequest implements IBulkAddItemsRequest {
    /** The list of products to add to the cart. */
    readonly items!: BulkAddItemsRequest_ItemRequest[] | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode!: string | undefined;

    constructor(data?: IBulkAddItemsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(BulkAddItemsRequest_ItemRequest.fromJS(item));
            }
            this.countryCode = _data["countryCode"];
        }
    }

    static fromJS(data: any): BulkAddItemsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddItemsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["countryCode"] = this.countryCode;
        return data;
    }
}

/** Represents a request to add multiple products to a cart. */
export interface IBulkAddItemsRequest {
    /** The list of products to add to the cart. */
    items: BulkAddItemsRequest_ItemRequest[] | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode: string | undefined;
}

/** Represents a request to add a product to a cart. */
export class BulkAddItemsRequest_ItemRequest implements IBulkAddItemsRequest_ItemRequest {
    /** The ProductConditionId for this listing. */
    sku!: number;
    /** Unique key of the seller. */
    sellerId!: number;
    /** Id of the channel. */
    channelId!: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity!: number;
    /** Expected price of the product to add to the cart. */
    price!: number | undefined;
    /** Whether the listing is intended to be included in the direct package. */
    isDirect!: boolean;
    /** The encrypted listo id. This value is null for any non-listo item. This allows for support for custom listings. */
    customListingKey!: string | undefined;

    constructor(data?: IBulkAddItemsRequest_ItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.sellerId = _data["sellerId"];
            this.channelId = _data["channelId"];
            this.requestedQuantity = _data["requestedQuantity"];
            this.price = _data["price"];
            this.isDirect = _data["isDirect"];
            this.customListingKey = _data["customListingKey"];
        }
    }

    static fromJS(data: any): BulkAddItemsRequest_ItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddItemsRequest_ItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["sellerId"] = this.sellerId;
        data["channelId"] = this.channelId;
        data["requestedQuantity"] = this.requestedQuantity;
        data["price"] = this.price;
        data["isDirect"] = this.isDirect;
        data["customListingKey"] = this.customListingKey;
        return data;
    }
}

/** Represents a request to add a product to a cart. */
export interface IBulkAddItemsRequest_ItemRequest {
    /** The ProductConditionId for this listing. */
    sku: number;
    /** Unique key of the seller. */
    sellerId: number;
    /** Id of the channel. */
    channelId: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity: number;
    /** Expected price of the product to add to the cart. */
    price: number | undefined;
    /** Whether the listing is intended to be included in the direct package. */
    isDirect: boolean;
    /** The encrypted listo id. This value is null for any non-listo item. This allows for support for custom listings. */
    customListingKey: string | undefined;
}

/** Represents the result of attempting to add multiple products to a cart. */
export class BulkAddItemsResponse implements IBulkAddItemsResponse {
    /** List of results for each product. */
    readonly items!: BulkAddItemsResponse_ItemResult[] | undefined;

    constructor(data?: IBulkAddItemsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(BulkAddItemsResponse_ItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkAddItemsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddItemsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents the result of attempting to add multiple products to a cart. */
export interface IBulkAddItemsResponse {
    /** List of results for each product. */
    items: BulkAddItemsResponse_ItemResult[] | undefined;
}

export class BulkAddItemsResponseApiResult implements IBulkAddItemsResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: BulkAddItemsResponse[] | undefined;
    result!: BulkAddItemsResponse;

    constructor(data?: IBulkAddItemsResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BulkAddItemsResponse.fromJS(item));
            }
            this.result = _data["result"] ? BulkAddItemsResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkAddItemsResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddItemsResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBulkAddItemsResponseApiResult {
    errors: ApiError[] | undefined;
    results: BulkAddItemsResponse[] | undefined;
    result: BulkAddItemsResponse;
}

/** Represents the result of attempting to add a product to a cart. */
export class BulkAddItemsResponse_ItemResult implements IBulkAddItemsResponse_ItemResult {
    /** Standardized Cart API error code */
    readonly status!: string | undefined;
    /** Sku of the product. */
    sku!: number;
    /** Unique id of the seller. */
    sellerId!: number;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect!: boolean;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable!: number | undefined;
    /** The amount of the requested quantity to be added that was successfully added. */
    quantityAdded!: number | undefined;
    /** Resulting quantity of the item in the cart. */
    quantity!: number | undefined;
    /** Current price of the product. */
    currentPrice!: number | undefined;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey!: string | undefined;

    constructor(data?: IBulkAddItemsResponse_ItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            this.sku = _data["sku"];
            this.sellerId = _data["sellerId"];
            this.isDirect = _data["isDirect"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            this.quantityAdded = _data["quantityAdded"];
            this.quantity = _data["quantity"];
            this.currentPrice = _data["currentPrice"];
            this.customListingKey = _data["customListingKey"];
        }
    }

    static fromJS(data: any): BulkAddItemsResponse_ItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddItemsResponse_ItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["sku"] = this.sku;
        data["sellerId"] = this.sellerId;
        data["isDirect"] = this.isDirect;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["quantityAdded"] = this.quantityAdded;
        data["quantity"] = this.quantity;
        data["currentPrice"] = this.currentPrice;
        data["customListingKey"] = this.customListingKey;
        return data;
    }
}

/** Represents the result of attempting to add a product to a cart. */
export interface IBulkAddItemsResponse_ItemResult {
    /** Standardized Cart API error code */
    status: string | undefined;
    /** Sku of the product. */
    sku: number;
    /** Unique id of the seller. */
    sellerId: number;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect: boolean;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable: number | undefined;
    /** The amount of the requested quantity to be added that was successfully added. */
    quantityAdded: number | undefined;
    /** Resulting quantity of the item in the cart. */
    quantity: number | undefined;
    /** Current price of the product. */
    currentPrice: number | undefined;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey: string | undefined;
}

/** A request to delete multiple products from a cart. */
export class BulkDeleteItemsRequest implements IBulkDeleteItemsRequest {
    /** The list of cartItemIds to delete from the cart. */
    items!: number[] | undefined;

    constructor(data?: IBulkDeleteItemsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkDeleteItemsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteItemsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }
}

/** A request to delete multiple products from a cart. */
export interface IBulkDeleteItemsRequest {
    /** The list of cartItemIds to delete from the cart. */
    items: number[] | undefined;
}

/** Represents a request to update multiple products in a cart. */
export class BulkUpdateItemsRequest implements IBulkUpdateItemsRequest {
    /** The list of products to update in the cart. */
    items!: BulkUpdateItemsRequest_ItemRequest[] | undefined;

    constructor(data?: IBulkUpdateItemsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BulkUpdateItemsRequest_ItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkUpdateItemsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateItemsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents a request to update multiple products in a cart. */
export interface IBulkUpdateItemsRequest {
    /** The list of products to update in the cart. */
    items: BulkUpdateItemsRequest_ItemRequest[] | undefined;
}

/** Represents a request to add a product to a cart. */
export class BulkUpdateItemsRequest_ItemRequest implements IBulkUpdateItemsRequest_ItemRequest {
    /** The cartItemId to update in the cart. */
    cartItemId!: number;
    /** Requested amount of the product to set this item to in the cart. */
    requestedQuantity!: number;

    constructor(data?: IBulkUpdateItemsRequest_ItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.requestedQuantity = _data["requestedQuantity"];
        }
    }

    static fromJS(data: any): BulkUpdateItemsRequest_ItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateItemsRequest_ItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["requestedQuantity"] = this.requestedQuantity;
        return data;
    }
}

/** Represents a request to add a product to a cart. */
export interface IBulkUpdateItemsRequest_ItemRequest {
    /** The cartItemId to update in the cart. */
    cartItemId: number;
    /** Requested amount of the product to set this item to in the cart. */
    requestedQuantity: number;
}

/** Represents the result of attempting to update multiple products in a cart. */
export class BulkUpdateItemsResponse implements IBulkUpdateItemsResponse {
    /** List of results for each product. */
    readonly items!: BulkUpdateItemsResponse_ItemResult[] | undefined;

    constructor(data?: IBulkUpdateItemsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(BulkUpdateItemsResponse_ItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkUpdateItemsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateItemsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents the result of attempting to update multiple products in a cart. */
export interface IBulkUpdateItemsResponse {
    /** List of results for each product. */
    items: BulkUpdateItemsResponse_ItemResult[] | undefined;
}

export class BulkUpdateItemsResponseApiResult implements IBulkUpdateItemsResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: BulkUpdateItemsResponse[] | undefined;
    result!: BulkUpdateItemsResponse;

    constructor(data?: IBulkUpdateItemsResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BulkUpdateItemsResponse.fromJS(item));
            }
            this.result = _data["result"] ? BulkUpdateItemsResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkUpdateItemsResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateItemsResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBulkUpdateItemsResponseApiResult {
    errors: ApiError[] | undefined;
    results: BulkUpdateItemsResponse[] | undefined;
    result: BulkUpdateItemsResponse;
}

/** Represents the result of attempting to add a product to a cart. */
export class BulkUpdateItemsResponse_ItemResult implements IBulkUpdateItemsResponse_ItemResult {
    /** Standardized Cart API error code */
    readonly status!: string | undefined;
    /** Id of the cart item. */
    cartItemId!: number;
    /** Whether the updated product is being fulfilled by TCG Direct. */
    isDirect!: boolean;
    /** Amount of product the seller of this item has available. */
    sellerQuantityAvailable!: number | undefined;

    constructor(data?: IBulkUpdateItemsResponse_ItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            this.cartItemId = _data["cartItemId"];
            this.isDirect = _data["isDirect"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
        }
    }

    static fromJS(data: any): BulkUpdateItemsResponse_ItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkUpdateItemsResponse_ItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["cartItemId"] = this.cartItemId;
        data["isDirect"] = this.isDirect;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        return data;
    }
}

/** Represents the result of attempting to add a product to a cart. */
export interface IBulkUpdateItemsResponse_ItemResult {
    /** Standardized Cart API error code */
    status: string | undefined;
    /** Id of the cart item. */
    cartItemId: number;
    /** Whether the updated product is being fulfilled by TCG Direct. */
    isDirect: boolean;
    /** Amount of product the seller of this item has available. */
    sellerQuantityAvailable: number | undefined;
}

export class CartItemResponse implements ICartItemResponse {
    cartItemId!: number;
    sku!: number;
    customListingKey!: string | undefined;
    quantity!: number;
    currentPrice!: number | undefined;
    savedPrice!: number | undefined;
    addedDt!: Date;
    updatedDt!: Date;
    sellerId!: number | undefined;
    isDirect!: boolean;
    giftCardKey!: string | undefined;

    constructor(data?: ICartItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.quantity = _data["quantity"];
            this.currentPrice = _data["currentPrice"];
            this.savedPrice = _data["savedPrice"];
            this.addedDt = _data["addedDt"] ? new Date(_data["addedDt"].toString()) : <any>undefined;
            this.updatedDt = _data["updatedDt"] ? new Date(_data["updatedDt"].toString()) : <any>undefined;
            this.sellerId = _data["sellerId"];
            this.isDirect = _data["isDirect"];
            this.giftCardKey = _data["giftCardKey"];
        }
    }

    static fromJS(data: any): CartItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["quantity"] = this.quantity;
        data["currentPrice"] = this.currentPrice;
        data["savedPrice"] = this.savedPrice;
        data["addedDt"] = this.addedDt ? this.addedDt.toISOString() : <any>undefined;
        data["updatedDt"] = this.updatedDt ? this.updatedDt.toISOString() : <any>undefined;
        data["sellerId"] = this.sellerId;
        data["isDirect"] = this.isDirect;
        data["giftCardKey"] = this.giftCardKey;
        return data;
    }
}

export interface ICartItemResponse {
    cartItemId: number;
    sku: number;
    customListingKey: string | undefined;
    quantity: number;
    currentPrice: number | undefined;
    savedPrice: number | undefined;
    addedDt: Date;
    updatedDt: Date;
    sellerId: number | undefined;
    isDirect: boolean;
    giftCardKey: string | undefined;
}

export class CartItemResponseListApiResult implements ICartItemResponseListApiResult {
    errors!: ApiError[] | undefined;
    results!: CartItemResponse[][] | undefined;
    result!: CartItemResponse[] | undefined;

    constructor(data?: ICartItemResponseListApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(CartItemResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CartItemResponseListApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemResponseListApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICartItemResponseListApiResult {
    errors: ApiError[] | undefined;
    results: CartItemResponse[][] | undefined;
    result: CartItemResponse[] | undefined;
}

/** Request to move cart items to Save for Later. */
export class MoveToSaveForLaterRequest implements IMoveToSaveForLaterRequest {
    /** Key of the cart to remove items from. */
    cartKey!: string | undefined;
    /** Wish list key to move items into. */
    saveForLaterKey!: string | undefined;
    /** Cart items to be moved. */
    readonly items!: MoveToSaveForLaterRequestItem[] | undefined;

    constructor(data?: IMoveToSaveForLaterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartKey = _data["cartKey"];
            this.saveForLaterKey = _data["saveForLaterKey"];
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(MoveToSaveForLaterRequestItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MoveToSaveForLaterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToSaveForLaterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartKey"] = this.cartKey;
        data["saveForLaterKey"] = this.saveForLaterKey;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Request to move cart items to Save for Later. */
export interface IMoveToSaveForLaterRequest {
    /** Key of the cart to remove items from. */
    cartKey: string | undefined;
    /** Wish list key to move items into. */
    saveForLaterKey: string | undefined;
    /** Cart items to be moved. */
    items: MoveToSaveForLaterRequestItem[] | undefined;
}

/** Cart item to be moved to Save for Later. */
export class MoveToSaveForLaterRequestItem implements IMoveToSaveForLaterRequestItem {
    /** Cart item's id. */
    cartItemId!: number;
    /** Item's SKU. */
    sku!: number;
    /** Listo's custom key. */
    customListingKey!: string | undefined;
    /** Cart item's quantity. */
    quantity!: number;

    constructor(data?: IMoveToSaveForLaterRequestItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): MoveToSaveForLaterRequestItem {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToSaveForLaterRequestItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["quantity"] = this.quantity;
        return data;
    }
}

/** Cart item to be moved to Save for Later. */
export interface IMoveToSaveForLaterRequestItem {
    /** Cart item's id. */
    cartItemId: number;
    /** Item's SKU. */
    sku: number;
    /** Listo's custom key. */
    customListingKey: string | undefined;
    /** Cart item's quantity. */
    quantity: number;
}

/** Results of moving cart items to Save for Later. */
export class MoveToSaveForLaterResult implements IMoveToSaveForLaterResult {
    /** Individual item statuses. */
    readonly itemStatuses!: MoveToSaveForLaterResultStatus[] | undefined;

    constructor(data?: IMoveToSaveForLaterResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemStatuses"])) {
                (<any>this).itemStatuses = [] as any;
                for (let item of _data["itemStatuses"])
                    (<any>this).itemStatuses!.push(MoveToSaveForLaterResultStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MoveToSaveForLaterResult {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToSaveForLaterResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemStatuses)) {
            data["itemStatuses"] = [];
            for (let item of this.itemStatuses)
                data["itemStatuses"].push(item.toJSON());
        }
        return data;
    }
}

/** Results of moving cart items to Save for Later. */
export interface IMoveToSaveForLaterResult {
    /** Individual item statuses. */
    itemStatuses: MoveToSaveForLaterResultStatus[] | undefined;
}

export class MoveToSaveForLaterResultApiResult implements IMoveToSaveForLaterResultApiResult {
    errors!: ApiError[] | undefined;
    results!: MoveToSaveForLaterResult[] | undefined;
    result!: MoveToSaveForLaterResult;

    constructor(data?: IMoveToSaveForLaterResultApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MoveToSaveForLaterResult.fromJS(item));
            }
            this.result = _data["result"] ? MoveToSaveForLaterResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MoveToSaveForLaterResultApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToSaveForLaterResultApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMoveToSaveForLaterResultApiResult {
    errors: ApiError[] | undefined;
    results: MoveToSaveForLaterResult[] | undefined;
    result: MoveToSaveForLaterResult;
}

/** Results for a single item moving to Save for Later. */
export class MoveToSaveForLaterResultStatus implements IMoveToSaveForLaterResultStatus {
    /** The former cart item id of the item. */
    cartItemId!: number;
    /** The quantity of the item before the add/update. */
    previousQuantity!: number | undefined;
    /** Status code for the item. */
    statusCode!: string | undefined;
    /** The new save for later item id if the move was successful. */
    saveForLaterItemId!: number | undefined;

    constructor(data?: IMoveToSaveForLaterResultStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.previousQuantity = _data["previousQuantity"];
            this.statusCode = _data["statusCode"];
            this.saveForLaterItemId = _data["saveForLaterItemId"];
        }
    }

    static fromJS(data: any): MoveToSaveForLaterResultStatus {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToSaveForLaterResultStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["previousQuantity"] = this.previousQuantity;
        data["statusCode"] = this.statusCode;
        data["saveForLaterItemId"] = this.saveForLaterItemId;
        return data;
    }
}

/** Results for a single item moving to Save for Later. */
export interface IMoveToSaveForLaterResultStatus {
    /** The former cart item id of the item. */
    cartItemId: number;
    /** The quantity of the item before the add/update. */
    previousQuantity: number | undefined;
    /** Status code for the item. */
    statusCode: string | undefined;
    /** The new save for later item id if the move was successful. */
    saveForLaterItemId: number | undefined;
}

/** Represents a request to update a product to a cart. */
export class UpdateItemRequest implements IUpdateItemRequest {
    /** Requested amount of the product to set this item to in the cart. */
    requestedQuantity!: number;
    /** Id of the channel of the item to be added to the cart. */
    channelId!: number;

    constructor(data?: IUpdateItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestedQuantity = _data["requestedQuantity"];
            this.channelId = _data["channelId"];
        }
    }

    static fromJS(data: any): UpdateItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestedQuantity"] = this.requestedQuantity;
        data["channelId"] = this.channelId;
        return data;
    }
}

/** Represents a request to update a product to a cart. */
export interface IUpdateItemRequest {
    /** Requested amount of the product to set this item to in the cart. */
    requestedQuantity: number;
    /** Id of the channel of the item to be added to the cart. */
    channelId: number;
}

/** Represents the result of attempting to update a product in a cart. */
export class UpdateItemResponse implements IUpdateItemResponse {
    /** Standardized Cart API error code */
    readonly status!: string | undefined;
    /** Whether the updated product is being fulfilled by TCG Direct. */
    isDirect!: boolean;
    /** Amount of product the seller of this item has available. */
    sellerQuantityAvailable!: number | undefined;

    constructor(data?: IUpdateItemResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            this.isDirect = _data["isDirect"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
        }
    }

    static fromJS(data: any): UpdateItemResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["isDirect"] = this.isDirect;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        return data;
    }
}

/** Represents the result of attempting to update a product in a cart. */
export interface IUpdateItemResponse {
    /** Standardized Cart API error code */
    status: string | undefined;
    /** Whether the updated product is being fulfilled by TCG Direct. */
    isDirect: boolean;
    /** Amount of product the seller of this item has available. */
    sellerQuantityAvailable: number | undefined;
}

export class UpdateItemResponseApiResult implements IUpdateItemResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: UpdateItemResponse[] | undefined;
    result!: UpdateItemResponse;

    constructor(data?: IUpdateItemResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UpdateItemResponse.fromJS(item));
            }
            this.result = _data["result"] ? UpdateItemResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateItemResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateItemResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateItemResponseApiResult {
    errors: ApiError[] | undefined;
    results: UpdateItemResponse[] | undefined;
    result: UpdateItemResponse;
}

/** Result of validating a cart item */
export class CartItemValidationResult implements ICartItemValidationResult {
    /** Result of the validation */
    status!: string | undefined;
    /** Id of the item */
    cartItemId!: number;
    /** SKU of the tiem */
    sku!: number;
    /** The custom listing id if the item is a custom listing. */
    customListingKey!: string | undefined;
    /** Original quantity of the item */
    quantity!: number;
    /** Quantity the associated seller has available */
    sellerQuantityAvailable!: number;
    /** Resulting effective quantity of the item */
    readonly resultingQuantity!: number;
    /** Original price of the item */
    savedPrice!: number;
    /** Current price of the item */
    currentPrice!: number;
    /** Id of the seller */
    sellerId!: number;
    /** Unique Key for the seller */
    sellerKey!: string | undefined;
    /** Whether the item is direct eligible */
    isDirect!: boolean;
    /** Key of the gift card if the item is a gift card */
    giftCardKey!: string | undefined;

    constructor(data?: ICartItemValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.cartItemId = _data["cartItemId"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.quantity = _data["quantity"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            (<any>this).resultingQuantity = _data["resultingQuantity"];
            this.savedPrice = _data["savedPrice"];
            this.currentPrice = _data["currentPrice"];
            this.sellerId = _data["sellerId"];
            this.sellerKey = _data["sellerKey"];
            this.isDirect = _data["isDirect"];
            this.giftCardKey = _data["giftCardKey"];
        }
    }

    static fromJS(data: any): CartItemValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["cartItemId"] = this.cartItemId;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["quantity"] = this.quantity;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["resultingQuantity"] = this.resultingQuantity;
        data["savedPrice"] = this.savedPrice;
        data["currentPrice"] = this.currentPrice;
        data["sellerId"] = this.sellerId;
        data["sellerKey"] = this.sellerKey;
        data["isDirect"] = this.isDirect;
        data["giftCardKey"] = this.giftCardKey;
        return data;
    }
}

/** Result of validating a cart item */
export interface ICartItemValidationResult {
    /** Result of the validation */
    status: string | undefined;
    /** Id of the item */
    cartItemId: number;
    /** SKU of the tiem */
    sku: number;
    /** The custom listing id if the item is a custom listing. */
    customListingKey: string | undefined;
    /** Original quantity of the item */
    quantity: number;
    /** Quantity the associated seller has available */
    sellerQuantityAvailable: number;
    /** Resulting effective quantity of the item */
    resultingQuantity: number;
    /** Original price of the item */
    savedPrice: number;
    /** Current price of the item */
    currentPrice: number;
    /** Id of the seller */
    sellerId: number;
    /** Unique Key for the seller */
    sellerKey: string | undefined;
    /** Whether the item is direct eligible */
    isDirect: boolean;
    /** Key of the gift card if the item is a gift card */
    giftCardKey: string | undefined;
}

/** Contains the list of validated cart items and a list of items that had to be moved to Save For Later. */
export class CartValidationResult implements ICartValidationResult {
    /** List of validated cart items */
    readonly cartItems!: CartItemValidationResult[] | undefined;
    /** List if invalid cart items that were moved to SaveForLater */
    readonly saveForLaterItems!: SaveForLaterItem[] | undefined;

    constructor(data?: ICartValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cartItems"])) {
                (<any>this).cartItems = [] as any;
                for (let item of _data["cartItems"])
                    (<any>this).cartItems!.push(CartItemValidationResult.fromJS(item));
            }
            if (Array.isArray(_data["saveForLaterItems"])) {
                (<any>this).saveForLaterItems = [] as any;
                for (let item of _data["saveForLaterItems"])
                    (<any>this).saveForLaterItems!.push(SaveForLaterItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CartValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        if (Array.isArray(this.saveForLaterItems)) {
            data["saveForLaterItems"] = [];
            for (let item of this.saveForLaterItems)
                data["saveForLaterItems"].push(item.toJSON());
        }
        return data;
    }
}

/** Contains the list of validated cart items and a list of items that had to be moved to Save For Later. */
export interface ICartValidationResult {
    /** List of validated cart items */
    cartItems: CartItemValidationResult[] | undefined;
    /** List if invalid cart items that were moved to SaveForLater */
    saveForLaterItems: SaveForLaterItem[] | undefined;
}

export class CartValidationResultApiResult implements ICartValidationResultApiResult {
    errors!: ApiError[] | undefined;
    results!: CartValidationResult[] | undefined;
    result!: CartValidationResult;

    constructor(data?: ICartValidationResultApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CartValidationResult.fromJS(item));
            }
            this.result = _data["result"] ? CartValidationResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartValidationResultApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new CartValidationResultApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartValidationResultApiResult {
    errors: ApiError[] | undefined;
    results: CartValidationResult[] | undefined;
    result: CartValidationResult;
}

/** Represents an item in the user's SaveForLater list */
export class SaveForLaterItem implements ISaveForLaterItem {
    /** Id of the item in Save For Later */
    saveForLaterId!: number;
    /** Status Code that caused the item to be saved for later. */
    status!: string | undefined;
    /** Status Code set on the cart item before the item was moved to save for later. */
    cartItemStatus!: string | undefined;
    /** SKU of the item */
    sku!: number;
    /** The custom listing id if the item is a custom listing. */
    customListingKey!: string | undefined;
    /** The associated gift card key */
    giftCardKey!: string | undefined;
    /** Quantity moved to Save For Later */
    quantity!: number;
    /** Original seller id of the item in cart */
    sellerId!: number;
    /** Original seller key of the item in cart */
    sellerKey!: string | undefined;

    constructor(data?: ISaveForLaterItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saveForLaterId = _data["saveForLaterId"];
            this.status = _data["status"];
            this.cartItemStatus = _data["cartItemStatus"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.giftCardKey = _data["giftCardKey"];
            this.quantity = _data["quantity"];
            this.sellerId = _data["sellerId"];
            this.sellerKey = _data["sellerKey"];
        }
    }

    static fromJS(data: any): SaveForLaterItem {
        data = typeof data === 'object' ? data : {};
        let result = new SaveForLaterItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saveForLaterId"] = this.saveForLaterId;
        data["status"] = this.status;
        data["cartItemStatus"] = this.cartItemStatus;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["giftCardKey"] = this.giftCardKey;
        data["quantity"] = this.quantity;
        data["sellerId"] = this.sellerId;
        data["sellerKey"] = this.sellerKey;
        return data;
    }
}

/** Represents an item in the user's SaveForLater list */
export interface ISaveForLaterItem {
    /** Id of the item in Save For Later */
    saveForLaterId: number;
    /** Status Code that caused the item to be saved for later. */
    status: string | undefined;
    /** Status Code set on the cart item before the item was moved to save for later. */
    cartItemStatus: string | undefined;
    /** SKU of the item */
    sku: number;
    /** The custom listing id if the item is a custom listing. */
    customListingKey: string | undefined;
    /** The associated gift card key */
    giftCardKey: string | undefined;
    /** Quantity moved to Save For Later */
    quantity: number;
    /** Original seller id of the item in cart */
    sellerId: number;
    /** Original seller key of the item in cart */
    sellerKey: string | undefined;
}

/** Represents the result of validating a cart. */
export class ValidationResponse implements IValidationResponse {
    /** List of validation results for each cart item. */
    readonly items!: ValidationResponse_ItemValidationResult[] | undefined;

    constructor(data?: IValidationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ValidationResponse_ItemValidationResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ValidationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents the result of validating a cart. */
export interface IValidationResponse {
    /** List of validation results for each cart item. */
    items: ValidationResponse_ItemValidationResult[] | undefined;
}

export class ValidationResponseApiResult implements IValidationResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: ValidationResponse[] | undefined;
    result!: ValidationResponse;

    constructor(data?: IValidationResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ValidationResponse.fromJS(item));
            }
            this.result = _data["result"] ? ValidationResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ValidationResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IValidationResponseApiResult {
    errors: ApiError[] | undefined;
    results: ValidationResponse[] | undefined;
    result: ValidationResponse;
}

/** Represents the validation result of a single item in a cart */
export class ValidationResponse_ItemValidationResult implements IValidationResponse_ItemValidationResult {
    /** Standardized Cart API status.  One of:
  Success = "Cart item is ok"
  CartItemQuantityNotAvailable = "Out of Stock, or the amount requested is greater than the amount available"
  CartItemQuantityInvalid
  SellerOffline
  SealedShippingRestriction
  SellerCannotShip
  InvalidGiftCardDeliveryDate
  CartShippingOptionInvalid
Note that errors lower in this list will take precedence over errors higher. e.g. If a seller is both
offline and out of stock for a cart item, the error given will be SellerOffline. */
    readonly status!: string | undefined;
    /** Id of the cart item. */
    cartItemId!: number;
    /** The ProductConditionId for this listing. */
    sku!: number;
    /** The encrypted, public id of a listo, if this cart item is a custom listing.  Null if not. */
    customListingKey!: string | undefined;
    /** Requested amount of the product in the cart. */
    quantity!: number;
    /** Amount of product this item has available from this seller. */
    sellerQuantityAvailable!: number;
    /** Price of this item at the time it was added to the cart. */
    savedPrice!: number;
    /** Current price of this item. */
    currentPrice!: number;
    /** Seller id of the seller of the item. */
    sellerId!: number;
    /** Key of the seller of the item. */
    sellerKey!: string | undefined;
    /** Whether the listing is included in the Direct package. */
    isDirect!: boolean;
    /** The key of the gift card item, if this cart item is a gift card.  Null if not. */
    giftCardKey!: string | undefined;

    constructor(data?: IValidationResponse_ItemValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            this.cartItemId = _data["cartItemId"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.quantity = _data["quantity"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            this.savedPrice = _data["savedPrice"];
            this.currentPrice = _data["currentPrice"];
            this.sellerId = _data["sellerId"];
            this.sellerKey = _data["sellerKey"];
            this.isDirect = _data["isDirect"];
            this.giftCardKey = _data["giftCardKey"];
        }
    }

    static fromJS(data: any): ValidationResponse_ItemValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResponse_ItemValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["cartItemId"] = this.cartItemId;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["quantity"] = this.quantity;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["savedPrice"] = this.savedPrice;
        data["currentPrice"] = this.currentPrice;
        data["sellerId"] = this.sellerId;
        data["sellerKey"] = this.sellerKey;
        data["isDirect"] = this.isDirect;
        data["giftCardKey"] = this.giftCardKey;
        return data;
    }
}

/** Represents the validation result of a single item in a cart */
export interface IValidationResponse_ItemValidationResult {
    /** Standardized Cart API status.  One of:
  Success = "Cart item is ok"
  CartItemQuantityNotAvailable = "Out of Stock, or the amount requested is greater than the amount available"
  CartItemQuantityInvalid
  SellerOffline
  SealedShippingRestriction
  SellerCannotShip
  InvalidGiftCardDeliveryDate
  CartShippingOptionInvalid
Note that errors lower in this list will take precedence over errors higher. e.g. If a seller is both
offline and out of stock for a cart item, the error given will be SellerOffline. */
    status: string | undefined;
    /** Id of the cart item. */
    cartItemId: number;
    /** The ProductConditionId for this listing. */
    sku: number;
    /** The encrypted, public id of a listo, if this cart item is a custom listing.  Null if not. */
    customListingKey: string | undefined;
    /** Requested amount of the product in the cart. */
    quantity: number;
    /** Amount of product this item has available from this seller. */
    sellerQuantityAvailable: number;
    /** Price of this item at the time it was added to the cart. */
    savedPrice: number;
    /** Current price of this item. */
    currentPrice: number;
    /** Seller id of the seller of the item. */
    sellerId: number;
    /** Key of the seller of the item. */
    sellerKey: string | undefined;
    /** Whether the listing is included in the Direct package. */
    isDirect: boolean;
    /** The key of the gift card item, if this cart item is a gift card.  Null if not. */
    giftCardKey: string | undefined;
}

/** Represents the result of attempting to add a gift card to a cart. */
export class AddGiftCardResponse implements IAddGiftCardResponse {
    status!: ErrorCodes_Code;
    /** The key of the gift card that was added to the cart. */
    giftCardKey!: string | undefined;

    constructor(data?: IAddGiftCardResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.giftCardKey = _data["giftCardKey"];
        }
    }

    static fromJS(data: any): AddGiftCardResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddGiftCardResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["giftCardKey"] = this.giftCardKey;
        return data;
    }
}

/** Represents the result of attempting to add a gift card to a cart. */
export interface IAddGiftCardResponse {
    status: ErrorCodes_Code;
    /** The key of the gift card that was added to the cart. */
    giftCardKey: string | undefined;
}

export class AddGiftCardResponseApiResult implements IAddGiftCardResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: AddGiftCardResponse[] | undefined;
    result!: AddGiftCardResponse;

    constructor(data?: IAddGiftCardResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AddGiftCardResponse.fromJS(item));
            }
            this.result = _data["result"] ? AddGiftCardResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AddGiftCardResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new AddGiftCardResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddGiftCardResponseApiResult {
    errors: ApiError[] | undefined;
    results: AddGiftCardResponse[] | undefined;
    result: AddGiftCardResponse;
}

/** Represents gift card data to be displayed in the UI. */
export class GiftCardData implements IGiftCardData {
    /** Id of the gift card template. */
    templateId!: number;
    /** Amount the gift card is worth. */
    amount!: number;
    /** Name of the person receiving the gift card. */
    toName!: string | undefined;
    /** Name of the person the gift card is from. */
    fromName!: string | undefined;
    /** Email address of the person receiving the gift card. */
    toEmail!: string | undefined;
    /** Optional message to include with the gift card. */
    message!: string | undefined;
    /** Optional timestamp for when the gift card should be sent. */
    deliverAfter!: Date | undefined;

    constructor(data?: IGiftCardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.amount = _data["amount"];
            this.toName = _data["toName"];
            this.fromName = _data["fromName"];
            this.toEmail = _data["toEmail"];
            this.message = _data["message"];
            this.deliverAfter = _data["deliverAfter"] ? new Date(_data["deliverAfter"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GiftCardData {
        data = typeof data === 'object' ? data : {};
        let result = new GiftCardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["amount"] = this.amount;
        data["toName"] = this.toName;
        data["fromName"] = this.fromName;
        data["toEmail"] = this.toEmail;
        data["message"] = this.message;
        data["deliverAfter"] = this.deliverAfter ? this.deliverAfter.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents gift card data to be displayed in the UI. */
export interface IGiftCardData {
    /** Id of the gift card template. */
    templateId: number;
    /** Amount the gift card is worth. */
    amount: number;
    /** Name of the person receiving the gift card. */
    toName: string | undefined;
    /** Name of the person the gift card is from. */
    fromName: string | undefined;
    /** Email address of the person receiving the gift card. */
    toEmail: string | undefined;
    /** Optional message to include with the gift card. */
    message: string | undefined;
    /** Optional timestamp for when the gift card should be sent. */
    deliverAfter: Date | undefined;
}

export class GiftCardDataApiResult implements IGiftCardDataApiResult {
    errors!: ApiError[] | undefined;
    results!: GiftCardData[] | undefined;
    result!: GiftCardData;

    constructor(data?: IGiftCardDataApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GiftCardData.fromJS(item));
            }
            this.result = _data["result"] ? GiftCardData.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GiftCardDataApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new GiftCardDataApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGiftCardDataApiResult {
    errors: ApiError[] | undefined;
    results: GiftCardData[] | undefined;
    result: GiftCardData;
}

/** Represents a request to add a gift card to a cart. */
export class GiftCardRequest implements IGiftCardRequest {
    /** Id of the gift card template to add. */
    templateId!: number;
    /** Amount the gift card should be worth. */
    amount!: number;
    /** Name of the person receiving the gift card. */
    toName!: string | undefined;
    /** Name of the person the gift card is from. */
    fromName!: string | undefined;
    /** Email address of the person receiving the gift card. */
    toEmail!: string | undefined;
    /** Optional message to include with the gift card. */
    message!: string | undefined;
    /** Optional timestamp for when the gift card should be sent. */
    deliverAfter!: Date | undefined;

    constructor(data?: IGiftCardRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.amount = _data["amount"];
            this.toName = _data["toName"];
            this.fromName = _data["fromName"];
            this.toEmail = _data["toEmail"];
            this.message = _data["message"];
            this.deliverAfter = _data["deliverAfter"] ? new Date(_data["deliverAfter"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GiftCardRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GiftCardRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["amount"] = this.amount;
        data["toName"] = this.toName;
        data["fromName"] = this.fromName;
        data["toEmail"] = this.toEmail;
        data["message"] = this.message;
        data["deliverAfter"] = this.deliverAfter ? this.deliverAfter.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents a request to add a gift card to a cart. */
export interface IGiftCardRequest {
    /** Id of the gift card template to add. */
    templateId: number;
    /** Amount the gift card should be worth. */
    amount: number;
    /** Name of the person receiving the gift card. */
    toName: string | undefined;
    /** Name of the person the gift card is from. */
    fromName: string | undefined;
    /** Email address of the person receiving the gift card. */
    toEmail: string | undefined;
    /** Optional message to include with the gift card. */
    message: string | undefined;
    /** Optional timestamp for when the gift card should be sent. */
    deliverAfter: Date | undefined;
}

/** Represents a request to add multiple products to a cart given only the skus for the products. */
export class BulkAddSkusToCartRequest implements IBulkAddSkusToCartRequest {
    /** The list of products to add to the cart. */
    items!: BulkAddSkusToCartRequest_ItemRequest[] | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode!: string | undefined;
    /** If true, allow some items to be added and any that cannot be fulfilled are skipped.
If false, only add the items if all of the items can be added. */
    allowPartialCompletion!: boolean;
    /** If true, only look for products that are available in Direct.
If false, products from any fulfiller can be added. */
    addFromDirectOnly!: boolean;

    constructor(data?: IBulkAddSkusToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BulkAddSkusToCartRequest_ItemRequest.fromJS(item));
            }
            this.countryCode = _data["countryCode"];
            this.allowPartialCompletion = _data["allowPartialCompletion"];
            this.addFromDirectOnly = _data["addFromDirectOnly"];
        }
    }

    static fromJS(data: any): BulkAddSkusToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddSkusToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["countryCode"] = this.countryCode;
        data["allowPartialCompletion"] = this.allowPartialCompletion;
        data["addFromDirectOnly"] = this.addFromDirectOnly;
        return data;
    }
}

/** Represents a request to add multiple products to a cart given only the skus for the products. */
export interface IBulkAddSkusToCartRequest {
    /** The list of products to add to the cart. */
    items: BulkAddSkusToCartRequest_ItemRequest[] | undefined;
    /** Code of the intended country to ship to. Used when checking for Direct eligibility. */
    countryCode: string | undefined;
    /** If true, allow some items to be added and any that cannot be fulfilled are skipped.
If false, only add the items if all of the items can be added. */
    allowPartialCompletion: boolean;
    /** If true, only look for products that are available in Direct.
If false, products from any fulfiller can be added. */
    addFromDirectOnly: boolean;
}

/** Represents a request to add a product to a cart. */
export class BulkAddSkusToCartRequest_ItemRequest implements IBulkAddSkusToCartRequest_ItemRequest {
    /** The ProductConditionId for this listing. */
    sku!: number;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey!: string | undefined;
    /** Id of the channel. */
    channelId!: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity!: number;

    constructor(data?: IBulkAddSkusToCartRequest_ItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.channelId = _data["channelId"];
            this.requestedQuantity = _data["requestedQuantity"];
        }
    }

    static fromJS(data: any): BulkAddSkusToCartRequest_ItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddSkusToCartRequest_ItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["channelId"] = this.channelId;
        data["requestedQuantity"] = this.requestedQuantity;
        return data;
    }
}

/** Represents a request to add a product to a cart. */
export interface IBulkAddSkusToCartRequest_ItemRequest {
    /** The ProductConditionId for this listing. */
    sku: number;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey: string | undefined;
    /** Id of the channel. */
    channelId: number;
    /** Requested amount of the product to add to the cart. */
    requestedQuantity: number;
}

/** Represents the result of attempting to add multiple skus to a cart. */
export class BulkAddSkusToCartResponse implements IBulkAddSkusToCartResponse {
    /** List of results for each product. */
    readonly items!: BulkAddSkusToCartResponse_ItemResult[] | undefined;

    constructor(data?: IBulkAddSkusToCartResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(BulkAddSkusToCartResponse_ItemResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkAddSkusToCartResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddSkusToCartResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** Represents the result of attempting to add multiple skus to a cart. */
export interface IBulkAddSkusToCartResponse {
    /** List of results for each product. */
    items: BulkAddSkusToCartResponse_ItemResult[] | undefined;
}

export class BulkAddSkusToCartResponseApiResult implements IBulkAddSkusToCartResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: BulkAddSkusToCartResponse[] | undefined;
    result!: BulkAddSkusToCartResponse;

    constructor(data?: IBulkAddSkusToCartResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BulkAddSkusToCartResponse.fromJS(item));
            }
            this.result = _data["result"] ? BulkAddSkusToCartResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkAddSkusToCartResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddSkusToCartResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBulkAddSkusToCartResponseApiResult {
    errors: ApiError[] | undefined;
    results: BulkAddSkusToCartResponse[] | undefined;
    result: BulkAddSkusToCartResponse;
}

/** Represents the result of attempting to add a product to a cart. */
export class BulkAddSkusToCartResponse_ItemResult implements IBulkAddSkusToCartResponse_ItemResult {
    /** Standardized Cart API error code */
    readonly status!: string | undefined;
    /** Sku of the product. */
    sku!: number;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey!: string | undefined;
    /** Unique id of the seller. */
    sellerId!: number | undefined;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect!: boolean | undefined;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable!: number | undefined;
    /** Resulting quantity of the item in the cart. */
    quantity!: number | undefined;
    /** The amount of the requested quantity to be added that was successfully added. */
    quantityAdded!: number | undefined;
    /** Current price of the product. */
    currentPrice!: number | undefined;
    /** Id of the cart item. */
    cartItemId!: number;

    constructor(data?: IBulkAddSkusToCartResponse_ItemResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).status = _data["status"];
            this.sku = _data["sku"];
            this.customListingKey = _data["customListingKey"];
            this.sellerId = _data["sellerId"];
            this.isDirect = _data["isDirect"];
            this.sellerQuantityAvailable = _data["sellerQuantityAvailable"];
            this.quantity = _data["quantity"];
            this.quantityAdded = _data["quantityAdded"];
            this.currentPrice = _data["currentPrice"];
            this.cartItemId = _data["cartItemId"];
        }
    }

    static fromJS(data: any): BulkAddSkusToCartResponse_ItemResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddSkusToCartResponse_ItemResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["sku"] = this.sku;
        data["customListingKey"] = this.customListingKey;
        data["sellerId"] = this.sellerId;
        data["isDirect"] = this.isDirect;
        data["sellerQuantityAvailable"] = this.sellerQuantityAvailable;
        data["quantity"] = this.quantity;
        data["quantityAdded"] = this.quantityAdded;
        data["currentPrice"] = this.currentPrice;
        data["cartItemId"] = this.cartItemId;
        return data;
    }
}

/** Represents the result of attempting to add a product to a cart. */
export interface IBulkAddSkusToCartResponse_ItemResult {
    /** Standardized Cart API error code */
    status: string | undefined;
    /** Sku of the product. */
    sku: number;
    /** The encrypted, public id of the listo, if a listo is intended to be added to the cart.
Null if this item is not a listo. */
    customListingKey: string | undefined;
    /** Unique id of the seller. */
    sellerId: number | undefined;
    /** Whether the added product is being fulfilled by TCG Direct. */
    isDirect: boolean | undefined;
    /** Amount of product the specified seller has available. */
    sellerQuantityAvailable: number | undefined;
    /** Resulting quantity of the item in the cart. */
    quantity: number | undefined;
    /** The amount of the requested quantity to be added that was successfully added. */
    quantityAdded: number | undefined;
    /** Current price of the product. */
    currentPrice: number | undefined;
    /** Id of the cart item. */
    cartItemId: number;
}

export class BulkAddToCartRequest implements IBulkAddToCartRequest {
    products!: BulkAddToCartRequest_Product[] | undefined;
    cartKey!: string | undefined;
    shippingCountry!: string | undefined;

    constructor(data?: IBulkAddToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(BulkAddToCartRequest_Product.fromJS(item));
            }
            this.cartKey = _data["cartKey"];
            this.shippingCountry = _data["shippingCountry"];
        }
    }

    static fromJS(data: any): BulkAddToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["cartKey"] = this.cartKey;
        data["shippingCountry"] = this.shippingCountry;
        return data;
    }
}

export interface IBulkAddToCartRequest {
    products: BulkAddToCartRequest_Product[] | undefined;
    cartKey: string | undefined;
    shippingCountry: string | undefined;
}

export class BulkAddToCartRequest_Product implements IBulkAddToCartRequest_Product {
    productId!: number;
    printing!: string | undefined;
    condition!: string | undefined;
    quantity!: number;

    constructor(data?: IBulkAddToCartRequest_Product) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.printing = _data["printing"];
            this.condition = _data["condition"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): BulkAddToCartRequest_Product {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddToCartRequest_Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["printing"] = this.printing;
        data["condition"] = this.condition;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IBulkAddToCartRequest_Product {
    productId: number;
    printing: string | undefined;
    condition: string | undefined;
    quantity: number;
}

export class BulkAddToCartResponse implements IBulkAddToCartResponse {
    products!: BulkAddToCartResponse_Product[] | undefined;

    constructor(data?: IBulkAddToCartResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(BulkAddToCartResponse_Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkAddToCartResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddToCartResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBulkAddToCartResponse {
    products: BulkAddToCartResponse_Product[] | undefined;
}

export class BulkAddToCartResponseApiResult implements IBulkAddToCartResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: BulkAddToCartResponse[] | undefined;
    result!: BulkAddToCartResponse;

    constructor(data?: IBulkAddToCartResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BulkAddToCartResponse.fromJS(item));
            }
            this.result = _data["result"] ? BulkAddToCartResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkAddToCartResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddToCartResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBulkAddToCartResponseApiResult {
    errors: ApiError[] | undefined;
    results: BulkAddToCartResponse[] | undefined;
    result: BulkAddToCartResponse;
}

export class BulkAddToCartResponse_Product implements IBulkAddToCartResponse_Product {
    productId!: number;
    condition!: string | undefined;
    printing!: string | undefined;
    sellerKey!: string | undefined;
    sellerName!: string | undefined;
    quantity!: number | undefined;
    price!: number | undefined;
    isDirect!: boolean;
    sellerShippingPrice!: number;
    statusCode!: ErrorCodes_Code;

    constructor(data?: IBulkAddToCartResponse_Product) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.condition = _data["condition"];
            this.printing = _data["printing"];
            this.sellerKey = _data["sellerKey"];
            this.sellerName = _data["sellerName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.isDirect = _data["isDirect"];
            this.sellerShippingPrice = _data["sellerShippingPrice"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): BulkAddToCartResponse_Product {
        data = typeof data === 'object' ? data : {};
        let result = new BulkAddToCartResponse_Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["condition"] = this.condition;
        data["printing"] = this.printing;
        data["sellerKey"] = this.sellerKey;
        data["sellerName"] = this.sellerName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["isDirect"] = this.isDirect;
        data["sellerShippingPrice"] = this.sellerShippingPrice;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IBulkAddToCartResponse_Product {
    productId: number;
    condition: string | undefined;
    printing: string | undefined;
    sellerKey: string | undefined;
    sellerName: string | undefined;
    quantity: number | undefined;
    price: number | undefined;
    isDirect: boolean;
    sellerShippingPrice: number;
    statusCode: ErrorCodes_Code;
}

/** A class containing information used to add mass entry items to a user's cart. */
export class MassEntryAddToCartRequest implements IMassEntryAddToCartRequest {
    /** The list of products to be added to the user's cart. */
    products!: MassEntryProduct[] | undefined;
    /** The selected product line. */
    selectedProductLineId!: number;
    /** A collection of the selected PrintingIds (sub type). */
    selectedPrintings!: MassEntryPrinting[] | undefined;
    /** A collection of the selected ConditionIds (super condition). */
    selectedConditions!: MassEntryCondition[] | undefined;
    /** The key associated with the cart to attempt to add products to. */
    cartKey!: string | undefined;
    /** The key associated with the user attempting to add products to their cart. */
    userKey!: string | undefined;
    /** The desired shipping country to check for product availability. */
    shippingCountry!: string | undefined;
    /** A key representing a TCGplayer affiliate. */
    partnerKey!: string | undefined;
    /** A unique key related to a user's session. */
    sessionId!: string | undefined;

    constructor(data?: IMassEntryAddToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(MassEntryProduct.fromJS(item));
            }
            this.selectedProductLineId = _data["selectedProductLineId"];
            if (Array.isArray(_data["selectedPrintings"])) {
                this.selectedPrintings = [] as any;
                for (let item of _data["selectedPrintings"])
                    this.selectedPrintings!.push(MassEntryPrinting.fromJS(item));
            }
            if (Array.isArray(_data["selectedConditions"])) {
                this.selectedConditions = [] as any;
                for (let item of _data["selectedConditions"])
                    this.selectedConditions!.push(MassEntryCondition.fromJS(item));
            }
            this.cartKey = _data["cartKey"];
            this.userKey = _data["userKey"];
            this.shippingCountry = _data["shippingCountry"];
            this.partnerKey = _data["partnerKey"];
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): MassEntryAddToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryAddToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["selectedProductLineId"] = this.selectedProductLineId;
        if (Array.isArray(this.selectedPrintings)) {
            data["selectedPrintings"] = [];
            for (let item of this.selectedPrintings)
                data["selectedPrintings"].push(item.toJSON());
        }
        if (Array.isArray(this.selectedConditions)) {
            data["selectedConditions"] = [];
            for (let item of this.selectedConditions)
                data["selectedConditions"].push(item.toJSON());
        }
        data["cartKey"] = this.cartKey;
        data["userKey"] = this.userKey;
        data["shippingCountry"] = this.shippingCountry;
        data["partnerKey"] = this.partnerKey;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

/** A class containing information used to add mass entry items to a user's cart. */
export interface IMassEntryAddToCartRequest {
    /** The list of products to be added to the user's cart. */
    products: MassEntryProduct[] | undefined;
    /** The selected product line. */
    selectedProductLineId: number;
    /** A collection of the selected PrintingIds (sub type). */
    selectedPrintings: MassEntryPrinting[] | undefined;
    /** A collection of the selected ConditionIds (super condition). */
    selectedConditions: MassEntryCondition[] | undefined;
    /** The key associated with the cart to attempt to add products to. */
    cartKey: string | undefined;
    /** The key associated with the user attempting to add products to their cart. */
    userKey: string | undefined;
    /** The desired shipping country to check for product availability. */
    shippingCountry: string | undefined;
    /** A key representing a TCGplayer affiliate. */
    partnerKey: string | undefined;
    /** A unique key related to a user's session. */
    sessionId: string | undefined;
}

/** A class containing information of the Mass Entry Add to Cart method's invocation. */
export class MassEntryAddToCartResponse implements IMassEntryAddToCartResponse {
    /** Gets or sets whether the Add to Cart succeeded. */
    success!: boolean;
    /** The Cart Key associated with the cart that the products are being added to. */
    cartKey!: string | undefined;
    /** A collection of the listings that were added. */
    readonly addedListings!: MassEntryAddedListing[] | undefined;
    /** A collection of error messages. */
    readonly errors!: MassEntryError[] | undefined;

    constructor(data?: IMassEntryAddToCartResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.cartKey = _data["cartKey"];
            if (Array.isArray(_data["addedListings"])) {
                (<any>this).addedListings = [] as any;
                for (let item of _data["addedListings"])
                    (<any>this).addedListings!.push(MassEntryAddedListing.fromJS(item));
            }
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(MassEntryError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MassEntryAddToCartResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryAddToCartResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["cartKey"] = this.cartKey;
        if (Array.isArray(this.addedListings)) {
            data["addedListings"] = [];
            for (let item of this.addedListings)
                data["addedListings"].push(item.toJSON());
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

/** A class containing information of the Mass Entry Add to Cart method's invocation. */
export interface IMassEntryAddToCartResponse {
    /** Gets or sets whether the Add to Cart succeeded. */
    success: boolean;
    /** The Cart Key associated with the cart that the products are being added to. */
    cartKey: string | undefined;
    /** A collection of the listings that were added. */
    addedListings: MassEntryAddedListing[] | undefined;
    /** A collection of error messages. */
    errors: MassEntryError[] | undefined;
}

export class MassEntryAddToCartResponseApiResult implements IMassEntryAddToCartResponseApiResult {
    errors!: ApiError[] | undefined;
    results!: MassEntryAddToCartResponse[] | undefined;
    result!: MassEntryAddToCartResponse;

    constructor(data?: IMassEntryAddToCartResponseApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(MassEntryAddToCartResponse.fromJS(item));
            }
            this.result = _data["result"] ? MassEntryAddToCartResponse.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MassEntryAddToCartResponseApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryAddToCartResponseApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMassEntryAddToCartResponseApiResult {
    errors: ApiError[] | undefined;
    results: MassEntryAddToCartResponse[] | undefined;
    result: MassEntryAddToCartResponse;
}

export class MassEntryAddedListing implements IMassEntryAddedListing {
    productId!: number;
    sellerKey!: string | undefined;
    sellerName!: string | undefined;
    quantity!: number;
    price!: number;
    condition!: string | undefined;
    isDirect!: boolean;
    sellerShippingPrice!: number;

    constructor(data?: IMassEntryAddedListing) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sellerKey = _data["sellerKey"];
            this.sellerName = _data["sellerName"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.condition = _data["condition"];
            this.isDirect = _data["isDirect"];
            this.sellerShippingPrice = _data["sellerShippingPrice"];
        }
    }

    static fromJS(data: any): MassEntryAddedListing {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryAddedListing();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sellerKey"] = this.sellerKey;
        data["sellerName"] = this.sellerName;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["condition"] = this.condition;
        data["isDirect"] = this.isDirect;
        data["sellerShippingPrice"] = this.sellerShippingPrice;
        return data;
    }
}

export interface IMassEntryAddedListing {
    productId: number;
    sellerKey: string | undefined;
    sellerName: string | undefined;
    quantity: number;
    price: number;
    condition: string | undefined;
    isDirect: boolean;
    sellerShippingPrice: number;
}

export class MassEntryCondition implements IMassEntryCondition {
    conditionId!: number;
    name!: string | undefined;

    constructor(data?: IMassEntryCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionId = _data["conditionId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MassEntryCondition {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionId"] = this.conditionId;
        data["name"] = this.name;
        return data;
    }
}

export interface IMassEntryCondition {
    conditionId: number;
    name: string | undefined;
}

/** A class containing mass entry error information. */
export class MassEntryError implements IMassEntryError {
    code!: string | undefined;
    message!: string | undefined;
    /** A collection of errors caused by invalid input. */
    readonly inputErrors!: MassEntryInputError[] | undefined;

    constructor(data?: IMassEntryError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
            if (Array.isArray(_data["inputErrors"])) {
                (<any>this).inputErrors = [] as any;
                for (let item of _data["inputErrors"])
                    (<any>this).inputErrors!.push(MassEntryInputError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MassEntryError {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        if (Array.isArray(this.inputErrors)) {
            data["inputErrors"] = [];
            for (let item of this.inputErrors)
                data["inputErrors"].push(item.toJSON());
        }
        return data;
    }
}

/** A class containing mass entry error information. */
export interface IMassEntryError {
    code: string | undefined;
    message: string | undefined;
    /** A collection of errors caused by invalid input. */
    inputErrors: MassEntryInputError[] | undefined;
}

/** A class containing mass entry input error information. */
export class MassEntryInputError implements IMassEntryInputError {
    /** The type of input error. */
    errorType!: string | undefined;
    /** The parsed line from the input. */
    error!: string | undefined;
    /** The entry with an input error. */
    entry!: string | undefined;

    constructor(data?: IMassEntryInputError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorType = _data["errorType"];
            this.error = _data["error"];
            this.entry = _data["entry"];
        }
    }

    static fromJS(data: any): MassEntryInputError {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryInputError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorType"] = this.errorType;
        data["error"] = this.error;
        data["entry"] = this.entry;
        return data;
    }
}

/** A class containing mass entry input error information. */
export interface IMassEntryInputError {
    /** The type of input error. */
    errorType: string | undefined;
    /** The parsed line from the input. */
    error: string | undefined;
    /** The entry with an input error. */
    entry: string | undefined;
}

export class MassEntryPrinting implements IMassEntryPrinting {
    printingId!: number;
    name!: string | undefined;

    constructor(data?: IMassEntryPrinting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.printingId = _data["printingId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): MassEntryPrinting {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryPrinting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["printingId"] = this.printingId;
        data["name"] = this.name;
        return data;
    }
}

export interface IMassEntryPrinting {
    printingId: number;
    name: string | undefined;
}

/** A class containing information about a mass entry product. */
export class MassEntryProduct implements IMassEntryProduct {
    /** The dbo.Product.ProductId associated with this product. */
    productId!: number | undefined;
    /** The name of the card. */
    name!: string | undefined;
    /** The quantity of the card. */
    quantity!: number | undefined;
    /** Gets or sets the Set Code for a specific listing. */
    setCode!: string | undefined;
    /** Gets or sets the original Set Code requested by the user for a specific listing. */
    originalSetCode!: string | undefined;
    /** Gets or sets the Card Number. */
    cardNumber!: string | undefined;
    /** Gets or Sets the Lowest Price. */
    lowestPrice!: number;

    constructor(data?: IMassEntryProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.setCode = _data["setCode"];
            this.originalSetCode = _data["originalSetCode"];
            this.cardNumber = _data["cardNumber"];
            this.lowestPrice = _data["lowestPrice"];
        }
    }

    static fromJS(data: any): MassEntryProduct {
        data = typeof data === 'object' ? data : {};
        let result = new MassEntryProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["setCode"] = this.setCode;
        data["originalSetCode"] = this.originalSetCode;
        data["cardNumber"] = this.cardNumber;
        data["lowestPrice"] = this.lowestPrice;
        return data;
    }
}

/** A class containing information about a mass entry product. */
export interface IMassEntryProduct {
    /** The dbo.Product.ProductId associated with this product. */
    productId: number | undefined;
    /** The name of the card. */
    name: string | undefined;
    /** The quantity of the card. */
    quantity: number | undefined;
    /** Gets or sets the Set Code for a specific listing. */
    setCode: string | undefined;
    /** Gets or sets the original Set Code requested by the user for a specific listing. */
    originalSetCode: string | undefined;
    /** Gets or sets the Card Number. */
    cardNumber: string | undefined;
    /** Gets or Sets the Lowest Price. */
    lowestPrice: number;
}

/** Saved seller shipping options for a cart */
export class SavedVendorShippingOption implements ISavedVendorShippingOption {
    sellerId!: number;
    shippingMethodCode!: string | undefined;
    price!: number;
    displayText!: string | undefined;

    constructor(data?: ISavedVendorShippingOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sellerId = _data["sellerId"];
            this.shippingMethodCode = _data["shippingMethodCode"];
            this.price = _data["price"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): SavedVendorShippingOption {
        data = typeof data === 'object' ? data : {};
        let result = new SavedVendorShippingOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sellerId"] = this.sellerId;
        data["shippingMethodCode"] = this.shippingMethodCode;
        data["price"] = this.price;
        data["displayText"] = this.displayText;
        return data;
    }
}

/** Saved seller shipping options for a cart */
export interface ISavedVendorShippingOption {
    sellerId: number;
    shippingMethodCode: string | undefined;
    price: number;
    displayText: string | undefined;
}

/** A class that defines a subset of user data. */
export class UserSummary implements IUserSummary {
    /** Database ID of the user */
    userId!: number | undefined;
    /** ProviderUserKey of the user */
    providerUserKey!: string | undefined;
    /** Username of the user */
    providerUserName!: string | undefined;
    /** External Id of the user */
    externalUserId!: string | undefined;

    constructor(data?: IUserSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.providerUserKey = _data["providerUserKey"];
            this.providerUserName = _data["providerUserName"];
            this.externalUserId = _data["externalUserId"];
        }
    }

    static fromJS(data: any): UserSummary {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["providerUserKey"] = this.providerUserKey;
        data["providerUserName"] = this.providerUserName;
        data["externalUserId"] = this.externalUserId;
        return data;
    }
}

/** A class that defines a subset of user data. */
export interface IUserSummary {
    /** Database ID of the user */
    userId: number | undefined;
    /** ProviderUserKey of the user */
    providerUserKey: string | undefined;
    /** Username of the user */
    providerUserName: string | undefined;
    /** External Id of the user */
    externalUserId: string | undefined;
}

export class UserSummaryApiResult implements IUserSummaryApiResult {
    errors!: ApiError[] | undefined;
    results!: UserSummary[] | undefined;
    result!: UserSummary;

    constructor(data?: IUserSummaryApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UserSummary.fromJS(item));
            }
            this.result = _data["result"] ? UserSummary.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserSummaryApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummaryApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserSummaryApiResult {
    errors: ApiError[] | undefined;
    results: UserSummary[] | undefined;
    result: UserSummary;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class BooleanApiResult implements IBooleanApiResult {
    errors!: ApiError[] | undefined;
    results!: boolean[] | undefined;
    result!: boolean;

    constructor(data?: IBooleanApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): BooleanApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["result"] = this.result;
        return data;
    }
}

export interface IBooleanApiResult {
    errors: ApiError[] | undefined;
    results: boolean[] | undefined;
    result: boolean;
}

export class StringApiResult implements IStringApiResult {
    errors!: ApiError[] | undefined;
    results!: string[] | undefined;
    result!: string | undefined;

    constructor(data?: IStringApiResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ApiError.fromJS(item));
            }
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(item);
            }
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): StringApiResult {
        data = typeof data === 'object' ? data : {};
        let result = new StringApiResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item);
        }
        data["result"] = this.result;
        return data;
    }
}

export interface IStringApiResult {
    errors: ApiError[] | undefined;
    results: string[] | undefined;
    result: string | undefined;
}

export class InvoiceTaxElement implements IInvoiceTaxElement {
    authority!: string | undefined;
    taxAmount!: number;

    constructor(data?: IInvoiceTaxElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authority = _data["authority"];
            this.taxAmount = _data["taxAmount"];
        }
    }

    static fromJS(data: any): InvoiceTaxElement {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceTaxElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authority"] = this.authority;
        data["taxAmount"] = this.taxAmount;
        return data;
    }
}

export interface IInvoiceTaxElement {
    authority: string | undefined;
    taxAmount: number;
}

export class InvoiceTaxes implements IInvoiceTaxes {
    invoiceId!: string | undefined;
    tcgTaxAmt!: number;
    sellerTaxAmt!: number;
    taxElements!: InvoiceTaxElement[] | undefined;
    isSuccessful!: boolean;

    constructor(data?: IInvoiceTaxes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoiceId = _data["invoiceId"];
            this.tcgTaxAmt = _data["tcgTaxAmt"];
            this.sellerTaxAmt = _data["sellerTaxAmt"];
            if (Array.isArray(_data["taxElements"])) {
                this.taxElements = [] as any;
                for (let item of _data["taxElements"])
                    this.taxElements!.push(InvoiceTaxElement.fromJS(item));
            }
            this.isSuccessful = _data["isSuccessful"];
        }
    }

    static fromJS(data: any): InvoiceTaxes {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceTaxes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceId"] = this.invoiceId;
        data["tcgTaxAmt"] = this.tcgTaxAmt;
        data["sellerTaxAmt"] = this.sellerTaxAmt;
        if (Array.isArray(this.taxElements)) {
            data["taxElements"] = [];
            for (let item of this.taxElements)
                data["taxElements"].push(item.toJSON());
        }
        data["isSuccessful"] = this.isSuccessful;
        return data;
    }
}

export interface IInvoiceTaxes {
    invoiceId: string | undefined;
    tcgTaxAmt: number;
    sellerTaxAmt: number;
    taxElements: InvoiceTaxElement[] | undefined;
    isSuccessful: boolean;
}

export class ApiError implements IApiError {
    code!: string | undefined;
    message!: string | undefined;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}

export interface IApiError {
    code: string | undefined;
    message: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}